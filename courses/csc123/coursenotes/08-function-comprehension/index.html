<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="x-ua-compatible" content="ie=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-site-verification" content="hIU2NRFm9Pwt76Z9R8DR92m2-kC85IQw6eIS3Ag7y7U" />
  <meta name="fediverse:creator" content="@ayaankazerouni@hci.social" />
  
  <meta name="robots" content="noindex">
  

	

	<title>Function comprehension - Ayaan M. Kazerouni</title>

	<link rel="stylesheet" href="/css/main.css" type="text/css">
  <link rel="stylesheet" href="/assets/academicons/css/academicons.min.css">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.1/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
	<link rel="canonical" href="https://ayaankazerouni.org/courses/csc123/coursenotes/08-function-comprehension/">
	<script src="/assets/js/footnote-preview.js" ></script>
</head>


<body>
  <main>
  
  
  
  <p>
  <a href="/courses/csc123/coursenotes">Coursenotes index</a> | <a href="/courses/csc123/fall2025">CSC 123 Introduction to Community Action Computing</a>
  <!-- <a href="/teaching">Ayaan M. Kazerouni <i class="fa fa-sign-out-alt"></i></a> -->
  </p>
  
  <div class="nav-links">
    
    <a href="/courses/csc123/coursenotes/07-functions-part-1/">&larr; Previous</a>
    
    
    <a href="/courses/csc123/coursenotes/09-design-recipe/">Next &rarr;</a>
    
  </div>
  <h1>Function comprehension</h1>
  <article>
      <p>We continue with our pattern for understanding: by considering data and allowed operations on that data.</p>

<p>We will focus on two aspects of functions as they relate to operations.
First, what are the operations that can be performed on functions?
Second, how do functions relate to operations?</p>

<p>There is a broader discussion to be had regarding the question <strong>Are functions themselves data?</strong> We will revisit that question later this term.</p>

<h2 id="steps-of-evaluation">Steps of evaluation</h2>

<p>Given the following function definition:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nf">return </span><span class="p">(</span><span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">34</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>What does the following expression evaluate to?</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>Did you determine that it evaluates to 38? If yes, good. If not, that’s ok. Either way, let us explore the steps of evaluation so that we can better understand what happens when a function is called.</p>

<h3 id="evaluating-a-function-call">Evaluating a function call</h3>

<p>Again, consider the following code:</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nf">return </span><span class="p">(</span><span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">34</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>When working with functions, we will track not only the <strong>steps of evaluation</strong> but also information that is <strong>known</strong> based on the code.</p>

<p>For instance, from this code we know the definition of function <code class="language-plaintext highlighter-rouge">f</code> and, it turns out, that the call <code class="language-plaintext highlighter-rouge">f(2)</code> evaluates to <em>something</em>.
We will track the <strong>Known information</strong> along with our steps of evaluation.</p>

<p>Below is a table that tracks the evaluation steps for this function call.
Step 1 starts us off.</p>

<p>To start with, we don’t have a value for <code class="language-plaintext highlighter-rouge">x</code>. <code class="language-plaintext highlighter-rouge">x</code> gets a value only once we start evaluating the function call <code class="language-plaintext highlighter-rouge">f(2)</code> (Step 2).</p>

<p>At each step, the (sub-)expression or statement that’s currently being evaluated is <u class="hlt">underlined and highlighted</u>.</p>

<table>
  <thead>
    <tr>
      <th>Step</th>
      <th>Under evaluation</th>
      <th>Known information</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td><u class="hlt"><code>f(2)</code></u></td>
      <td><code>const f = (x: number): number =&gt; {<br />&nbsp;return (x * x) + 34;<br />}<br /><br />x = ?<br /><br />f(2) = ?</code></td>
    </tr>
    <tr>
      <td>2</td>
      <td><code>return (<u class="hlt">x</u> * x) + 34</code></td>
      <td><code>const f = (x: number): number =&gt; {<br />&nbsp;return (x * x) + 34;<br />}<br /><br />x = 2<br /><br />f(2) = ?</code></td>
    </tr>
    <tr>
      <td>3</td>
      <td><code>return (2 * <u class="hlt">x</u>) + 34</code></td>
      <td><code>const f = (x: number): number =&gt; {<br />&nbsp;return (x * x) + 34;<br />}<br /><br />x = 2<br /><br />f(2) = ?</code></td>
    </tr>
    <tr>
      <td>4</td>
      <td><code>return (<u class="hlt">2 * 2</u>) + 34</code></td>
      <td><code>const f = (x: number): number =&gt; {<br />&nbsp;return (x * x) + 34;<br />}<br /><br />x = 2<br /><br />f(2) = ?</code></td>
    </tr>
    <tr>
      <td>5</td>
      <td><code>return <u class="hlt">4 + 34</u></code></td>
      <td><code>const f = (x: number): number =&gt; {<br />&nbsp;return (x * x) + 34;<br />}<br /><br />x = 2<br /><br />f(2) = ?</code></td>
    </tr>
    <tr>
      <td>6</td>
      <td><code><u class="hlt">return 38</u></code></td>
      <td><code>const f = (x: number): number =&gt; {<br />&nbsp;return (x * x) + 34;<br />}<br /><br />x = 2<br /><br />f(2) = <b>38</b></code></td>
    </tr>
  </tbody>
</table>

<p>The result of the function call is determined by the <code class="language-plaintext highlighter-rouge">return</code> statement. Once the value to be returned is determined, then the result of the function is known (as shown, in bold, in the last row).</p>

<h2 id="another-example">Another example</h2>

<p>To emphasise the point, let’s work through another example.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">g</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">+</span> <span class="nf">g</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">g</span> <span class="o">=</span> <span class="p">(</span><span class="nx">y</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">y</span> <span class="o">*</span> <span class="p">(</span><span class="nx">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="nf">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>This call to function <code class="language-plaintext highlighter-rouge">f</code> looks very similar to the previous evaluation, and in many respects it is.
The steps of evaluation for the function call itself are the same for every function:</p>

<ul>
  <li>Determine the values of the parameters,</li>
  <li>Bind those values to the corresponding parameters (i.e., substitute those values in place of the parameters), and</li>
  <li>Evaluate the function’s body, that is, walk through the computations defined within the function.</li>
</ul>

<h3 id="evaluation-of-f2">Evaluation of f(2)</h3>

<p>We begin, as before, with the evaluation of the function call. The complete evaluation is lengthy, so the presentation is split into pieces, but you will soon discover another important reason for this split.</p>

<table>
  <thead>
    <tr>
      <th>Step</th>
      <th>Under evaluation</th>
      <th>Known</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td><code>f(2)</code></td>
      <td><code>const f = (x: number): number =&gt; {<br />&nbsp;return g(x) + g(x + 1);<br />}<br /><br />const g = (y: number): number =&gt; {<br />&nbsp;return y * (y - 1);<br />}<br /><br />f(2)</code></td>
    </tr>
    <tr>
      <td>2</td>
      <td><code>x = 2<br />return g(<u>x</u>) + g(x + 1)</code></td>
      <td><code>const f = (x: number): number =&gt; {<br />&nbsp;return g(x) + g(x + 1);<br />}<br /><br />const g = (y: number): number =&gt; {<br />&nbsp;return y * (y - 1);<br />}<br /><br />f(2) = ?</code></td>
    </tr>
    <tr>
      <td>3</td>
      <td><code>x = 2<br />return g(2) + g(<u>x</u> + 1) | <code>const f = (x: number): number =&gt; {<br />&nbsp;return g(x) + g(x + 1);<br />}<br /><br />const g = (y: number): number =&gt; {<br />&nbsp;return y * (y - 1);<br />}<br /><br />f(2) = ?<br />g(2) = ?</code></code></td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>In step 2, we need to deal with the line <code class="language-plaintext highlighter-rouge">g(x) + g(x + 1)</code>. Recall that when functions are “called”, they can be dealt with as <em>expressions</em>. This means that the entire line <code class="language-plaintext highlighter-rouge">g(x) + g(x + 1)</code> should be evaluated as an expression. We do this by first evaluating each of its sub-expressions, starting with <code class="language-plaintext highlighter-rouge">g(x)</code>.</p>

<p>The variable <code class="language-plaintext highlighter-rouge">x</code> determines the value that is given to this call to function <code class="language-plaintext highlighter-rouge">g</code>. The variable itself is not passed to the function. Instead, the variable <code class="language-plaintext highlighter-rouge">x</code> is evaluated first to determine its value (as we would do if, say, we were simply evaluating the expression <code class="language-plaintext highlighter-rouge">x + 1</code>).</p>

<p>But what comes next?</p>

<p>As demonstrated when evaluating arithmetic expressions (such as <code class="language-plaintext highlighter-rouge">x + y</code>), the left operand is evaluated before the right and then the result of the arithmetic can be determined.
Similarly, Step 3 must evaluate <code class="language-plaintext highlighter-rouge">g(2)</code> as described above.</p>

<p>This is, of course, another function call.
This new call must be evaluated before the evaluation of <code class="language-plaintext highlighter-rouge">f(2)</code> can complete.
Note, as well, the addition of <code class="language-plaintext highlighter-rouge">g(2)</code> to the <strong>Known information</strong> in the table.
We know that <code class="language-plaintext highlighter-rouge">g(2)</code> evaluates to <em>something</em>—we need to work out what.</p>

<h3 id="evaluating-the-nested-function-call">Evaluating the nested function call</h3>

<p>Let us temporarily suspend the evaluation of the call <code class="language-plaintext highlighter-rouge">f(2)</code> and consider the call <code class="language-plaintext highlighter-rouge">g(2)</code>.</p>

<p>In Step 1 below, all we know is that <code class="language-plaintext highlighter-rouge">g(2)</code> evaluates to something.
So we need to expand the function call and consider the function body. This means that the parameter now has a value. 
In Step 2, we have the additional information that <code class="language-plaintext highlighter-rouge">y = 2</code>.
The evaluation continues like we’ve seen before.</p>

<table>
  <thead>
    <tr>
      <th>Step</th>
      <th>Under evaluation</th>
      <th>Known</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td><code>g(2)</code></td>
      <td><code>const f = (x: number): number =&gt; {<br />&nbsp;return g(x) + g(x + 1);<br />}<br /><br />const g = (y: number): number =&gt; {<br />&nbsp;return y * (y - 1);<br />}<br /><br />f(2) = \&lt;in progress\&gt;<br />g(2) = ?</code></td>
    </tr>
    <tr>
      <td>2</td>
      <td><code>y = 2</code><br /><code>return <u>y</u> * (y - 1)</code></td>
      <td><code>const f = (x: number): number =&gt; {<br />&nbsp;return g(x) + g(x + 1);<br />}<br /><br />const g = (y: number): number =&gt; {<br />&nbsp;return y * (y - 1);<br />}<br /><br />f(2) = \&lt;in progress\&gt;<br />g(2) = ?</code></td>
    </tr>
    <tr>
      <td>3</td>
      <td><code>y = 2</code><br /><code>return 2 * (<u>y</u> - 1)</code></td>
      <td><code>const f = (x: number): number =&gt; {<br />&nbsp;return g(x) + g(x + 1);<br />}<br /><br />const g = (y: number): number =&gt; {<br />&nbsp;return y * (y - 1);<br />}<br /><br />f(2) = \&lt;in progress\&gt;<br />g(2) = ?</code></td>
    </tr>
    <tr>
      <td>4</td>
      <td><code>y = 2</code><br /><code>return 2 * (<u>2 - 1</u>)</code></td>
      <td><code>const f = (x: number): number =&gt; {<br />&nbsp;return g(x) + g(x + 1);<br />}<br /><br />const g = (y: number): number =&gt; {<br />&nbsp;return y * (y - 1);<br />}<br /><br />f(2) = \&lt;in progress\&gt;<br />g(2) = ?</code></td>
    </tr>
    <tr>
      <td>5</td>
      <td><code>y = 2</code><br /><code>return <u>2 * 1</u></code></td>
      <td><code>const f = (x: number): number =&gt; {<br />&nbsp;return g(x) + g(x + 1);<br />}<br /><br />const g = (y: number): number =&gt; {<br />&nbsp;return y * (y - 1);<br />}<br /><br />f(2) = \&lt;in progress\&gt;<br />g(2) = ?</code></td>
    </tr>
    <tr>
      <td>6</td>
      <td><code>y = 2</code><br /><code><u>return 2</u></code></td>
      <td><code>const f = (x: number): number =&gt; {<br />&nbsp;return g(x) + g(x + 1);<br />}<br /><br />const g = (y: number): number =&gt; {<br />&nbsp;return y * (y - 1);<br />}<br /><br />f(2) = \&lt;in progress\&gt;<br /><b>g(2) = 2</b></code></td>
    </tr>
  </tbody>
</table>

<p>Recall that we were in the middle of evaluating <code class="language-plaintext highlighter-rouge">g(x) + g(x + 1)</code> in the function <code class="language-plaintext highlighter-rouge">f</code>. Since we called <code class="language-plaintext highlighter-rouge">f(2)</code>, we know that <code class="language-plaintext highlighter-rouge">x = 2</code> inside <code class="language-plaintext highlighter-rouge">f</code>.
We also now know that <code class="language-plaintext highlighter-rouge">g(2)</code> gives us the value <code class="language-plaintext highlighter-rouge">2</code>.</p>

<p>So we have <code class="language-plaintext highlighter-rouge">2 + g(x + 1)</code>. We can continue evaluating the rest of this expression, following the same steps that we have outlined.
We need to start by evaluating the sub-expression <code class="language-plaintext highlighter-rouge">g(x + 1)</code>.</p>

<p>Following the steps we’ve learned:</p>

<ul>
  <li>First, substitute in the value 2 in place of <code class="language-plaintext highlighter-rouge">x</code>. This gives us <code class="language-plaintext highlighter-rouge">g(2 + 1)</code>, which can be reduced to <code class="language-plaintext highlighter-rouge">g(3)</code>.</li>
  <li>We can follow the same evaluation steps once again trace execution of the <code class="language-plaintext highlighter-rouge">g</code> function. This time, we are substituting in the value <code class="language-plaintext highlighter-rouge">3</code> for the parameter <code class="language-plaintext highlighter-rouge">y</code> in the definition of <code class="language-plaintext highlighter-rouge">g</code>.</li>
  <li>In the <code class="language-plaintext highlighter-rouge">g</code> function, we have <code class="language-plaintext highlighter-rouge">y * (y - 1)</code>. Substituting in the value <code class="language-plaintext highlighter-rouge">3</code>, we get <code class="language-plaintext highlighter-rouge">3 * (3 - 2)</code>, which evaluates to <code class="language-plaintext highlighter-rouge">6</code>. This value is returned back to the function <code class="language-plaintext highlighter-rouge">f</code>.</li>
  <li>Back in function <code class="language-plaintext highlighter-rouge">f</code>, we had <code class="language-plaintext highlighter-rouge">2 + g(x + 1)</code>. After evaluating <code class="language-plaintext highlighter-rouge">g(x + 1)</code> (with <code class="language-plaintext highlighter-rouge">x = 2</code>), we ended up with the expression <code class="language-plaintext highlighter-rouge">2 + 6</code>, which evaluates further to <code class="language-plaintext highlighter-rouge">8</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">8</code> is a value that cannot be evaluated any further, and so the function <code class="language-plaintext highlighter-rouge">f</code> can return this value.</li>
</ul>

<p>Therefore, at the end of the following code:</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">g</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">+</span> <span class="nf">g</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">g</span> <span class="o">=</span> <span class="p">(</span><span class="nx">y</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">y</span> <span class="o">*</span> <span class="p">(</span><span class="nx">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="nf">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>We can say f(2) gives us the value 8.</p>

<h2 id="thatsa-lot">That’s….a lot</h2>

<p>The level of details in tracking these evaluation steps as just presented can be a bit daunting. This is presented not because you are expected to write such steps explicitly (certainly not frequently) but rather to emphasize the very important individual steps and considerations involved. These are summarized below.</p>

<ul>
  <li>The arguments to a function call are evaluated before the call begins (we need to pass values).</li>
  <li>The values from these arguments are bound to the named parameters (by corresponding position from left-to-right).</li>
  <li>The evaluation of a function call is paused if the function makes another call.</li>
  <li>The expression within a return statement must be evaluated to determine the value to be returned (the result of the function).</li>
  <li>A function call is an expression that evaluates to the returned value.</li>
</ul>

<hr />

      <footer class="nav-links">
        
        <a href="/courses/csc123/coursenotes/07-functions-part-1/">&larr; Previous</a>
        
        
        <a href="/courses/csc123/coursenotes/09-design-recipe/">Next &rarr;</a>
        
      </footer  >
  </article>
  
  
  </main>
</body>
</html>
