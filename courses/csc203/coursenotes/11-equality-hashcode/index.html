<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="x-ua-compatible" content="ie=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-site-verification" content="hIU2NRFm9Pwt76Z9R8DR92m2-kC85IQw6eIS3Ag7y7U" />

	<title>Equality and hashcode - Ayaan M. Kazerouni</title>

	<link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/assets/academicons/css/academicons.min.css">
  <link rel="stylesheet" href="/css/github.css">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.1/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
	<link rel="canonical" href="https://ayaankazerouni.org/courses/csc203/coursenotes/11-equality-hashcode/">
	<link href='https://fonts.googleapis.com/css?family=Open+Sans:400,300,700,800,600' rel='stylesheet' type='text/css'>
	<link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
	<link href='https://fonts.googleapis.com/css?family=Muli:400,300' rel='stylesheet' type='text/css'>
	<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
</head>


<body>
  <main class="coursenotes">
  
  
  
  
  <p>
    (Coursenotes for <a href="/courses/csc203">CSC 203 Project-based Object-oriented Programming and Design</a>)
  </p>
  
  <h1>Equality and hashcode</h1>
    <div class="content-box" style="border: none;">
      <div class="content">
        
        <p>(Work in progress)</p>

<p>We’ll take a little detour from polymorphism to learn about <em>equality</em> in Java.</p>

<h2 id="methods-inherited-from-object">Methods inherited from Object</h2>

<p>We have previously talked about the <code class="language-plaintext highlighter-rouge">Object</code> class, which is the root of the type hierarchy in Java.
That is, all reference types in Java are subtypes of <code class="language-plaintext highlighter-rouge">Object</code>, which means that all child types in Java can <em>at least</em> perform all the behaviours that <code class="language-plaintext highlighter-rouge">Object</code> can perform. 
These reference types can either inherit <code class="language-plaintext highlighter-rouge">Object</code>’s behaviour for these methods, or they can override them by writing their own versions of those methods.</p>

<p>Below are some of the methods defined in the <code class="language-plaintext highlighter-rouge">Object</code> class.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">public String toString()</code>: Computes and returns a <code class="language-plaintext highlighter-rouge">String</code> representation of the object. For the <code class="language-plaintext highlighter-rouge">Object</code> class, this simply returns the object’s memory address. This (not super useful) behaviour will be inherited by a subclass unless the subclass overrides it by writing its own <code class="language-plaintext highlighter-rouge">toString</code> method.</li>
  <li><code class="language-plaintext highlighter-rouge">public boolean equals(Object other)</code>: Checks if this <code class="language-plaintext highlighter-rouge">Object</code> (the calling object) is logically equal to the <code class="language-plaintext highlighter-rouge">other</code> object. For the <code class="language-plaintext highlighter-rouge">Object</code> class, this method checks if they are the same object (i.e., it is the same as using the <code class="language-plaintext highlighter-rouge">==</code> operator). If a subclass wants to define a more useful <code class="language-plaintext highlighter-rouge">equals</code> method, it must override it.</li>
  <li><code class="language-plaintext highlighter-rouge">public int hashCode()</code>: Computes the object’s <em>hash code</em>, a (hopefully) unique number used by structures like <code class="language-plaintext highlighter-rouge">HashMap</code>s and <code class="language-plaintext highlighter-rouge">HashSet</code>s to enable to fast searches for the matching object.</li>
</ul>

<h2 id="tostring"><code class="language-plaintext highlighter-rouge">toString</code></h2>

<p>The <code class="language-plaintext highlighter-rouge">Object</code> class defines a <code class="language-plaintext highlighter-rouge">toString</code> method whose job it is to return a short, human friendly string representation of the object.
For a plain old <code class="language-plaintext highlighter-rouge">Object</code> which is almost never used directly by developers, this <code class="language-plaintext highlighter-rouge">toString</code> method simply returns the object’s address in memory.
The <code class="language-plaintext highlighter-rouge">Object</code> has no other distinguishing features, so there’s not much more to say about it.</p>

<p><strong>You should always override <code class="language-plaintext highlighter-rouge">toString</code> when you write your own classes.</strong> It’s often useful to have a <code class="language-plaintext highlighter-rouge">toString</code> method for your own classes.
It brings a number of conveniences.</p>

<ol>
  <li>You can simply “print” an object’s info by giving the object as an argument to <code class="language-plaintext highlighter-rouge">System.out.print</code>. The <code class="language-plaintext highlighter-rouge">print</code> method will automatically call <code class="language-plaintext highlighter-rouge">toString</code> on whatever its argument is, if its argument is not a <code class="language-plaintext highlighter-rouge">String</code>. If you don’t write a <code class="language-plaintext highlighter-rouge">toString</code> method, the runtime will simply move up the type hierarchy until it finds a <code class="language-plaintext highlighter-rouge">toString</code> method, and call that instead.<sup id="fnref:polymorphism" role="doc-noteref"><a href="#fn:polymorphism" class="footnote" rel="footnote">1</a></sup></li>
  <li>When you give your object a <code class="language-plaintext highlighter-rouge">toString</code> method, you “buy into” a larger ecosystem of libraries.</li>
</ol>

<p>For example, suppose you’ve created your own custom linked list class, called <code class="language-plaintext highlighter-rouge">MyLinkedList</code>.
For simplicity, let’s say the list contains integers, and you are performing some complex operations on this linked list.</p>

<p>You will hopefully be writing tests to check that your list functions are behaving as expected. E.g., you might write something like this:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Expected value is a list like 1 --&gt; 2 --&gt; 3</span>
<span class="nc">MyLinkedList</span> <span class="n">expected</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyLinkedList</span><span class="o">(</span><span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="kc">null</span><span class="o">)));</span>
<span class="nc">MyLinkedList</span> <span class="n">actual</span> <span class="o">=</span> <span class="o">....</span> <span class="c1">// Assume you have called some complex function here that returns a list</span>
<span class="n">assertEquals</span><span class="o">(</span><span class="n">expected</span><span class="o">,</span> <span class="n">actual</span><span class="o">);</span>
</code></pre></div></div>

<p>If your test passes, all well and good.
However, if your test fails, you’re going to see an error message like this:</p>

<pre><code class="language-txt">Expected: MyLinkedList@eb2184
Actual: MyLinkedList@ai02481
</code></pre>

<p>The JUnit failure message for <code class="language-plaintext highlighter-rouge">assertEquals</code> automatically uses the object’s <code class="language-plaintext highlighter-rouge">toString</code> method to communicate the expected value and actual values to the user.
If you do not write a <code class="language-plaintext highlighter-rouge">toString</code> method, you’re going to get the gibberish above.</p>

<p>If you <em>do</em> write a <code class="language-plaintext highlighter-rouge">toString</code> method, you will get much nicer error messages in JUnit.
For example, assuming you wrote a <code class="language-plaintext highlighter-rouge">toString</code> method that prints out each node’s value with an arrow between them, you would see the following:</p>

<pre><code class="language-txt">Expected: 1 --&gt; 2 --&gt; 3
Actual: 3 --&gt; 2 --&gt; 1
</code></pre>

<p>Much easier to interpret!</p>

<p><strong>In general, IDEs and libraries will use the <code class="language-plaintext highlighter-rouge">toString</code> method whenever they need to refer to an object in text output for a human to read.</strong></p>

<p>Another really important example is the <a href="https://www.jetbrains.com/help/idea/debugging-code.html">debugger in IntelliJ IDEA</a> and most other Java IDEs. When you inspect a variable’s value while debugging, the debugger by default displays the result of calling <code class="language-plaintext highlighter-rouge">toString</code> on that variable.
Without a <code class="language-plaintext highlighter-rouge">toString</code> method for custom classes, you are just going to be given the memory address.</p>

<p>For example, consider the image below, reproduced from <a href="https://www.jetbrains.com/help/idea/debug-tool-window.html#sessions">IntelliJ’s help docs</a>. In the screenshot, the user is inspecting the <code class="language-plaintext highlighter-rouge">this</code> object, which appears to be a <code class="language-plaintext highlighter-rouge">Whale</code> object.
Unfortunately, the <code class="language-plaintext highlighter-rouge">Whale</code> in this example does <em>not</em> have a <code class="language-plaintext highlighter-rouge">toString</code> method, so the user has to expand the <code class="language-plaintext highlighter-rouge">this</code> object to inspect its data.
If the <code class="language-plaintext highlighter-rouge">Whale</code> <em>did</em> have a <code class="language-plaintext highlighter-rouge">toString</code>, that value would be printed instead of <code class="language-plaintext highlighter-rouge">{Whale@784}</code> (the object’s memory address).</p>

<figure>

  <a href="debugger.png" target="_blank">
    
    <img src="debugger.png" alt="" />
    
  </a>
  <figcaption>A screenshot of a debugger session. Notice the 'Whale@784'.</figcaption>
</figure>

<p>A well-written <code class="language-plaintext highlighter-rouge">toString</code> can make this type of debugging go much faster.</p>

<h3 id="tostring-should-not-have-any-side-effects"><code class="language-plaintext highlighter-rouge">toString</code> should not have any side-effects!</h3>

<p>This is a <strong>REALLY IMPORTANT</strong> requirement of <code class="language-plaintext highlighter-rouge">toString</code> methods. A <code class="language-plaintext highlighter-rouge">toString</code> method must <strong>not</strong>, under any circumstances, make changes to an object, or generally have any other effects other than computing and returning a <code class="language-plaintext highlighter-rouge">String</code>.</p>

<p>Because the <code class="language-plaintext highlighter-rouge">toString</code> method is implicitly used by so many libraries, it can lead to really subtle and hard-to-track-down bugs if the <code class="language-plaintext highlighter-rouge">toString</code> method also causes other effects like mutations, or writing to a file.</p>

<p>A real example: In Spring 2023, in CSC 305, a student was reading from a file in their <code class="language-plaintext highlighter-rouge">toString</code> method. And each file read was triggering a “cache counter” which counted how many times the file was read. Imagine their surprise when the program worked differently when it was run in debug mode vs. regular mode vs. test mode! Each use of <code class="language-plaintext highlighter-rouge">toString</code> (whether the student called it themselves or not) caused the cache counter to trigger — this means that, in addition to normal circumstances, the cache counter got triggered when a JUnit test case tried to display results, when they tried debug their program and the debugger tried to display variable values.</p>

<p>It was a nightmare to debug.</p>

<h2 id="equals"><code class="language-plaintext highlighter-rouge">equals</code></h2>

<p>Next up, we will talk about the <code class="language-plaintext highlighter-rouge">equals</code> method in Java.
All the way in the <a href="../01-intro-java/">first lesson</a>, we talked about how reference types (i.e., objects) must <em>not</em> be checked for equality using the <code class="language-plaintext highlighter-rouge">==</code> operator.
We must instead use the <code class="language-plaintext highlighter-rouge">.equals</code> method.</p>

<p>The <code class="language-plaintext highlighter-rouge">Object</code> class provides an <code class="language-plaintext highlighter-rouge">equals</code> method that all classes inherit, unless they write their own <code class="language-plaintext highlighter-rouge">equals</code> method.
This “fallback” <code class="language-plaintext highlighter-rouge">equals</code> method does the same check as <code class="language-plaintext highlighter-rouge">==</code> — it checks if two variables’ memory addresses are the same.
That is, it checks if they both point to the same object.</p>

<p>Like we’ve seen, this is not super useful.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Person</code> class example</li>
  <li>Method signature for equals</li>
  <li>Each required check and the reason for it</li>
</ul>

<h2 id="hashcode"><code class="language-plaintext highlighter-rouge">hashCode</code></h2>

<ul>
  <li>What it is used for</li>
  <li>How to write one</li>
</ul>

<hr />

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:polymorphism" role="doc-endnote">
      <p>This is a good example of polymorphism. The <code class="language-plaintext highlighter-rouge">System.out.print</code> method asks for an <code class="language-plaintext highlighter-rouge">Object</code> as a parameter. The actual argument its given might be <em>any type</em>, as long as it’s a subtype of <code class="language-plaintext highlighter-rouge">Object</code>. All the <code class="language-plaintext highlighter-rouge">print</code> method cares about is that its input can produce a string representation of itself, i.e., it can call <code class="language-plaintext highlighter-rouge">toString</code>. <a href="#fnref:polymorphism" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

    </div>
    
    
    </article>
  </main>
</body>
</html>
