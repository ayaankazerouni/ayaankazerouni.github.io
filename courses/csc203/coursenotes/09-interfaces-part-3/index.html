<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="x-ua-compatible" content="ie=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-site-verification" content="hIU2NRFm9Pwt76Z9R8DR92m2-kC85IQw6eIS3Ag7y7U" />

	<title>Interfaces (part 3) - Ayaan M. Kazerouni</title>

	<link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/assets/academicons/css/academicons.min.css">
  <link rel="stylesheet" href="/css/github.css">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.1/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
	<link rel="canonical" href="https://ayaankazerouni.org/courses/csc203/coursenotes/09-interfaces-part-3/">
	<link href='https://fonts.googleapis.com/css?family=Open+Sans:400,300,700,800,600' rel='stylesheet' type='text/css'>
	<link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
	<link href='https://fonts.googleapis.com/css?family=Muli:400,300' rel='stylesheet' type='text/css'>
	<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
</head>


<body>
  <main class="coursenotes">
  
  
  
  
  <p>
    (Coursenotes for <a href="/courses/csc203">CSC 203 Project-based Object-oriented Programming and Design</a>)
  </p>
  
  <h1>Interfaces (part 3)</h1>
    <div class="content-box" style="border: none;">
      <div class="content">
        
        <h2 id="objectives">Objectives</h2>

<p>In this lesson you will learn:</p>

<ul>
  <li>About hierarchical relationships between interfaces, i.e., <code class="language-plaintext highlighter-rouge">public interface InterfaceA extends InterfaceB</code>.</li>
  <li>About how a class can implement multiple interfaces, i.e., <code class="language-plaintext highlighter-rouge">public class MyClass implements InterfaceA, InterfaceB</code>.</li>
  <li>About <code class="language-plaintext highlighter-rouge">default</code> methods in interfaces.</li>
  <li>About “the diamond” problem, i.e., what happens when a class inherits two implementations of the same method.</li>
</ul>

<h2 id="recap">Recap</h2>

<p class="callout"><strong>Interfaces</strong> allow us to define <em>what</em> a type should be able to do, but not <em>how</em> it should do it.
We do this through the use of <strong>abstract methods</strong> that define a method signature, but no method body.
Implementing subclasses must including implementations for those methods, and can include additional methods if needed.</p>

<p>In the previous lessons we learned about <em>interfaces</em>—both the general idea, as well as the embodiment of that idea in the form of the <code class="language-plaintext highlighter-rouge">interface</code> construct in the Java language.</p>

<p>Continuing with our running example of the Nim game, we came up with the following class design for the game.</p>

<p>The <code class="language-plaintext highlighter-rouge">Game</code> class has two <code class="language-plaintext highlighter-rouge">Player</code>s and a <code class="language-plaintext highlighter-rouge">Pile</code> of sticks.
The <code class="language-plaintext highlighter-rouge">Player</code> is an interface, which means that at run time the <code class="language-plaintext highlighter-rouge">Player</code> might be any kind of available <code class="language-plaintext highlighter-rouge">Player</code> subtype, and the <code class="language-plaintext highlighter-rouge">Game</code> doesn’t know or care which.
The <code class="language-plaintext highlighter-rouge">Player</code> interface, in other words, sits between the <code class="language-plaintext highlighter-rouge">Game</code> and the different player implementations, hiding those implementation details from other parts of the system.</p>

<pre class="mermaid">
classDiagram
  direction LR
  note for Game "Underlined members are static." 
  Game --&gt; `interface Player` : has two
  Game --&gt; Pile : has a
  `interface Player` &lt;|-- TimidPlayer : is a 
  `interface Player` &lt;|-- GreedyPlayer : is a 
  `interface Player` &lt;|-- RandomPlayer : is a 

  class Game {
    +Player p1
    +Player p2
    +Pile pile
    playGame() void$
  }

  class `interface Player` {
    +getName() String*
    +takeTurn(Pile) int*
  }

  namespace PlayerSubtypes {
    class TimidPlayer { }

    class GreedyPlayer {
      +String jeer
      +jeer() String
    }

    class RandomPlayer { }
  }

  class Pile {
    +int numSticks
    +remove(int) void
    +getSticks() int
  }
</pre>

<p>For the rest of this lesson, for the sake brevity, we will only include the <code class="language-plaintext highlighter-rouge">Player</code> and its subtypes when we consider a diagrammatic view of the class structure.</p>

<h2 id="interfaces-can-extend-interfaces">Interfaces can extend interfaces</h2>

<p>In this lesson, we are going to consider how to incorporate yet more features into our Nim game.</p>

<p>In the design above, we have included support for the <code class="language-plaintext highlighter-rouge">GreedyPlayer</code> to <code class="language-plaintext highlighter-rouge">jeer</code> at their opponent each time they take a turn.</p>

<p>Let’s suppose want to add support for multiple types of “chatty” players in our system.
That is, we don’t want <em>only</em> our <code class="language-plaintext highlighter-rouge">GreedyPlayer</code> to be able to print a message each time they take a turn—we want to allow <em>any</em> new <code class="language-plaintext highlighter-rouge">Player</code> type to optionally have this ability.</p>

<p>Let’s consider some options to accomplish this.</p>

<h3 id="option-1--give-all-players-the-ability-to-print-a-message">Option 1 — Give all players the ability to print a message</h3>

<p>We could give all of our <code class="language-plaintext highlighter-rouge">Player</code> subtypes a <code class="language-plaintext highlighter-rouge">makeComment()</code> method that prints the <code class="language-plaintext highlighter-rouge">Player</code>’s comment to the screen.
We can also give them a <code class="language-plaintext highlighter-rouge">makeComment(String)</code> overload that prints the specified message to the screen, instead of the <code class="language-plaintext highlighter-rouge">Player</code>’s pre-defined message.</p>

<p>An advantage of this approach is that it’s <em>simple</em>.
We can stick a <em><code class="language-plaintext highlighter-rouge">makeComment</code></em> overloaded abstract methods in the <code class="language-plaintext highlighter-rouge">Player</code> interface, and all implementing subclasses can print their chosen message.</p>

<p>A disadvantage is that this would reduce the <em>cohesiveness</em> of our <code class="language-plaintext highlighter-rouge">Player</code> type.
For example, the <code class="language-plaintext highlighter-rouge">TimidPlayer</code> has no intention of presenting a message each time they take a turn — what should the <code class="language-plaintext highlighter-rouge">TimidPlayer</code>’s <code class="language-plaintext highlighter-rouge">makeComment()</code> method return? An empty string (<code class="language-plaintext highlighter-rouge">""</code>)? <code class="language-plaintext highlighter-rouge">null</code>? Some string that will never be used?</p>

<p>The <code class="language-plaintext highlighter-rouge">Player</code> interface is now less cohesive because it includes behaviour (<code class="language-plaintext highlighter-rouge">message()</code>) that is not relevant to <em>all</em> <code class="language-plaintext highlighter-rouge">Player</code> instances.</p>

<h3 id="option-2--break-out-the-chatty-behaviour-into-another-type">Option 2 — Break out the chatty behaviour into another type</h3>

<p>Option 2 is to separate the behaviour of playing games and “socializing” — they are separate concerns that don’t need to be implemented together.</p>

<p>We can do this by creating a separate <code class="language-plaintext highlighter-rouge">interface</code> for <code class="language-plaintext highlighter-rouge">SocialPlayer</code>s.
The <code class="language-plaintext highlighter-rouge">SocialPlayer</code> interface will <em>extend</em> the <code class="language-plaintext highlighter-rouge">Player</code> interface.</p>

<p>The <code class="language-plaintext highlighter-rouge">SocialPlayer</code> interface looks like the following:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">SocialPlayer</span> <span class="kd">extends</span> <span class="nc">Player</span> <span class="o">{</span>
  <span class="kt">void</span> <span class="nf">makeComment</span><span class="o">();</span> <span class="c1">// prints some pre-defined comment</span>
  <span class="kt">void</span> <span class="nf">makeComment</span><span class="o">(</span><span class="nc">String</span> <span class="n">message</span><span class="o">);</span> <span class="c1">// prints the specified message</span>
<span class="o">}</span>
</code></pre></div></div>

<p class="callout">In the code above, we use the <strong><code class="language-plaintext highlighter-rouge">extends</code></strong> keyword to declare that the <code class="language-plaintext highlighter-rouge">SocialPlayer</code> <code class="language-plaintext highlighter-rouge">interface</code> is a subtype of the <code class="language-plaintext highlighter-rouge">Player</code> <code class="language-plaintext highlighter-rouge">interface</code>. That is, all <code class="language-plaintext highlighter-rouge">SocialPlayer</code>s are <code class="language-plaintext highlighter-rouge">Player</code>s.</p>

<p>The <code class="language-plaintext highlighter-rouge">SocialPlayer</code> only declares one (overloaded) behaviour—the <code class="language-plaintext highlighter-rouge">makeComment</code> methods.
Any class that <code class="language-plaintext highlighter-rouge">implements SocialPlayer</code> must now include implementations of <code class="language-plaintext highlighter-rouge">Player</code> methods <em>and</em> implementations of <code class="language-plaintext highlighter-rouge">SocialPlayer</code> methods.</p>

<p>In our updated Nim game, our <code class="language-plaintext highlighter-rouge">GreedyPlayer</code> is a <code class="language-plaintext highlighter-rouge">SocialPlayer</code>, which means it can take turns in the game like all <code class="language-plaintext highlighter-rouge">Player</code>s, but can also send <code class="language-plaintext highlighter-rouge">message</code>s.</p>

<p>Here is what the <code class="language-plaintext highlighter-rouge">Player</code> type hierarchy looks like now. In the diagram below, we use <code class="language-plaintext highlighter-rouge">implements</code> or <code class="language-plaintext highlighter-rouge">extends</code> to show the specific keyword used to define the “is a” relationship between a child type and its parent type.</p>

<pre class="mermaid">
classDiagram
  direction TB
  `interface Player` &lt;|-- `interface SocialPlayer` : extends
  `interface Player` &lt;|-- TimidPlayer : implements 
  `interface Player` &lt;|-- RandomPlayer : implements 
  `interface SocialPlayer` &lt;|-- GreedyPlayer : implements 

  class `interface Player` {
    +getName() String*
    +takeTurn(Pile) int*
  }
  
  class `interface SocialPlayer` {
    +makeComment() void*
    +makeComment(String message) void*
  }

  namespace PlayerSubtypes {
    class TimidPlayer { }

    class GreedyPlayer { }

    class RandomPlayer { }
  }
</pre>

<p>Our <code class="language-plaintext highlighter-rouge">GreedyPlayer</code> implementation would look the same as before (except instead of <code class="language-plaintext highlighter-rouge">jeer</code> we now use the more general <code class="language-plaintext highlighter-rouge">makeComment</code> methods to chat).
But now we can incorporate additional player types that have social behaviours, and treat them all as <code class="language-plaintext highlighter-rouge">SocialPlayer</code>s in other parts of the system.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GreedyPlayer</span> <span class="kd">implements</span> <span class="nc">SocialPlayer</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">jeer</span><span class="o">;</span> <span class="c1">// This player talks smack</span>
  
  <span class="kd">public</span> <span class="nf">GreedyPlayer</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">String</span> <span class="n">jeer</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">jeer</span> <span class="o">=</span> <span class="n">jeer</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeComment</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">jeer</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeComment</span><span class="o">(</span><span class="nc">String</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>  
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">takeTurn</span><span class="o">(</span><span class="nc">Pile</span> <span class="n">pile</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">toRemove</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">pile</span><span class="o">.</span><span class="na">getSticks</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">toRemove</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="n">toRemove</span> <span class="o">=</span> <span class="n">pile</span><span class="o">.</span><span class="na">getSticks</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">toRemove</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="whats-the-benefit-of-doing-this">What’s the benefit of doing this?</h3>

<p>The <code class="language-plaintext highlighter-rouge">Player</code> interface introduced a uniform set of behaviours that the <code class="language-plaintext highlighter-rouge">Game</code> could rely on; i.e., it could expect all <code class="language-plaintext highlighter-rouge">Player</code> objects to be able to do things like taking a turn, no matter what kind of player subtype they were.</p>

<p>Similarly, the <code class="language-plaintext highlighter-rouge">SocialPlayer</code> interface introduces a uniform set of <em>additional</em> behaviours that some players can perform—they can make comments.
This opens up an avenue for a version of the <code class="language-plaintext highlighter-rouge">Game</code> that allows some players (those that support social behaviours) to make comments during game play.</p>

<p>Consider this updated <code class="language-plaintext highlighter-rouge">play</code> method for the <code class="language-plaintext highlighter-rouge">Game</code> class.
In the code below, each time a <code class="language-plaintext highlighter-rouge">Player</code> takes a turn, we give the <code class="language-plaintext highlighter-rouge">opponent</code> the opportunity to print a message.</p>

<p>We use the <code class="language-plaintext highlighter-rouge">instanceof</code> operator to check if the <code class="language-plaintext highlighter-rouge">opponent</code> is an instance of the <code class="language-plaintext highlighter-rouge">SocialPlayer</code> type, and if so, we print the message.
The <code class="language-plaintext highlighter-rouge">SocialPlayer</code> interface allows us to change our “view” of the <code class="language-plaintext highlighter-rouge">opponent</code> object, deciding whether to see it as simply a <code class="language-plaintext highlighter-rouge">Player</code>, or as a <code class="language-plaintext highlighter-rouge">SocialPlayer</code>, depending on what set of behaviours we mean to invoke.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">play</span><span class="o">(</span><span class="nc">Player</span> <span class="n">p</span><span class="o">,</span> <span class="nc">Pile</span> <span class="n">pile</span><span class="o">,</span> <span class="nc">Player</span> <span class="n">opponent</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">sticksTaken</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">takeTurn</span><span class="o">(</span><span class="n">pile</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\n"</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" takes "</span> <span class="o">+</span> <span class="n">sticksTaken</span> <span class="o">+</span> <span class="s">" sticks.\n"</span> <span class="o">+</span>
    <span class="s">"There are "</span> <span class="o">+</span> <span class="n">pile</span><span class="o">.</span><span class="na">getSticks</span><span class="o">()</span> <span class="o">+</span> <span class="s">" left in the pile."</span><span class="o">);</span>

  <span class="c1">// Each time a player takes a turn, if the opponent is a social player,</span>
  <span class="c1">// print a vaguely threatening message.</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">opponent</span> <span class="k">instanceof</span> <span class="nc">SocialPlayer</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">((</span><span class="nc">SocialPlayer</span><span class="o">)</span> <span class="n">opponent</span><span class="o">).</span><span class="na">makeComment</span><span class="o">(</span><span class="s">"Bad move, "</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">"!"</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">pile</span><span class="o">.</span><span class="na">getSticks</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>      
<span class="o">}</span>
</code></pre></div></div>

<p class="callout ponder">Do you think this is a reasonable use of the <code class="language-plaintext highlighter-rouge">instanceof</code> operator? Is there any way to print the opponent’s message from the <code class="language-plaintext highlighter-rouge">SocialPlayer</code> implementing subclasses directly?</p>

<p>In the example, we are dealing with both “views” of the <code class="language-plaintext highlighter-rouge">opponent</code> in the same method.</p>

<p>As a larger example, consider if we wrote a separate, feature-rich “chatroom” module for this Nim game.
We can make that module <em>only</em> view players as <code class="language-plaintext highlighter-rouge">SocialPlayer</code>s, since it is only interested in the behaviours relevant to social interactions, and not game play.</p>

<h2 id="classes-can-implement-multiple-interfaces">Classes can implement multiple interfaces</h2>

<p>What if, as part of our expanded Nim application, we wanted to also support general “socializers”? That is, users who are not players in the Nim game, but are still able to make comments that other users can see?</p>

<p>As things currently stand, to create “socializers”—users that can make comments—we would need to implement the <code class="language-plaintext highlighter-rouge">SocialPlayer</code> interface.
Unfortunately, this brings with it a fair bit of baggage — if you implement the commenting behaviour from the <code class="language-plaintext highlighter-rouge">SocialPlayer</code>, you need to also implement the game play behaviour from the <code class="language-plaintext highlighter-rouge">Player</code> interface.
This is due to the hierarchical relationship between <code class="language-plaintext highlighter-rouge">SocialPlayer</code> and <code class="language-plaintext highlighter-rouge">Player</code>: all <code class="language-plaintext highlighter-rouge">SocialPlayer</code>s are <code class="language-plaintext highlighter-rouge">Player</code>s.</p>

<p>We can decouple the socializing functionality from the gameplay functionality by removing the hierarchical relationship between those interfaces.
That is, instead of wrapping social behaviours into a <code class="language-plaintext highlighter-rouge">SocialPlayer</code> interface that is a child type of <code class="language-plaintext highlighter-rouge">Player</code>, we can create two separate, unrelated interfaces:</p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">Player</code> interface for gameplay behaviours, unchanged from what we have seen so far.</li>
  <li>The <code class="language-plaintext highlighter-rouge">Socializer</code> interface for social behaviours, like making comments.</li>
</ul>

<p class="callout">In Java, classes can implement multiple interfaces. These interfaces provide different “views” to the class, or different, well, interfaces through which to interact with the class.</p>

<p>The player subtypes that only support gameplay functionality (like <code class="language-plaintext highlighter-rouge">TimidPlayer</code> and <code class="language-plaintext highlighter-rouge">RandomPlayer</code>) will implement only the <code class="language-plaintext highlighter-rouge">Player</code> interface.
The player subtypes that want to support both gameplay functionality <em>and</em> socializing functionality (like <code class="language-plaintext highlighter-rouge">GreedyPlayer</code>) will implement <em>both</em> the <code class="language-plaintext highlighter-rouge">Player</code> and <code class="language-plaintext highlighter-rouge">Socializer</code> interfaces.
Finally, the users that want to only support socializing functionality (say, <code class="language-plaintext highlighter-rouge">Spectator</code> or <code class="language-plaintext highlighter-rouge">Referee</code> objects) will only implement the <code class="language-plaintext highlighter-rouge">Socializer</code> interfaces.</p>

<p>Here is what our new class structure would look like.
By separating the <code class="language-plaintext highlighter-rouge">Player</code> and <code class="language-plaintext highlighter-rouge">Socializer</code> interfaces (instead of having them have a hierarchical relationship), we have allowed classes to more flexibly combine or not combine those behaviours.</p>

<pre class="mermaid">
classDiagram
  direction TB
  `interface Player` &lt;|-- TimidPlayer : implements 
  `interface Player` &lt;|-- RandomPlayer : implements 
  `interface Player` &lt;|-- GreedyPlayer : implements 
  `interface Socializer` &lt;|-- GreedyPlayer : implements 
  `interface Socializer` &lt;|-- Spectator : implements
  `interface Socializer` &lt;|-- Referee : implements

  class `interface Player` {
    +getName() String*
    +takeTurn(Pile) int*
  }

  class `interface Socializer` {
    +makeComment() void*
    +makeComment(String message) void*
  }

  class TimidPlayer { }

  class GreedyPlayer { }

  class RandomPlayer { }
</pre>

<p>To support the structure above, our <code class="language-plaintext highlighter-rouge">GreedyPlayer</code> only needs to change its signature to implement the two interfaces.
Everything else in the class would remain the same: it still needs to implement all <code class="language-plaintext highlighter-rouge">Player</code> behaviours, and it still needs to implement all <code class="language-plaintext highlighter-rouge">Socializer</code> behaviours.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GreedyPlayer</span> <span class="kd">implements</span> <span class="nc">Player</span><span class="o">,</span> <span class="nc">Socializer</span> <span class="o">{</span>
  <span class="c1">// Rest of the GreedyPlayer class remains the same</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="default-methods">default methods</h2>

<p>The <code class="language-plaintext highlighter-rouge">GreedyPlayer</code>, <code class="language-plaintext highlighter-rouge">Spectator</code>, and <code class="language-plaintext highlighter-rouge">Referee</code> objects all have to include implementations for the two <code class="language-plaintext highlighter-rouge">makeComment</code> methods from the <code class="language-plaintext highlighter-rouge">Socializer</code> interface.
The overload that has no parameters, i.e., <code class="language-plaintext highlighter-rouge">makeComment()</code>, will be different for each implementation.</p>

<p>It makes sense for those three classes to implement their own versions of <code class="language-plaintext highlighter-rouge">makeComment()</code>.</p>
<ul>
  <li>The <code class="language-plaintext highlighter-rouge">GreedyPlayer</code> prints its <code class="language-plaintext highlighter-rouge">jeer</code>.</li>
  <li>The <code class="language-plaintext highlighter-rouge">Spectator</code> might print support a message of support for the player that has their allegiance.</li>
  <li>The <code class="language-plaintext highlighter-rouge">Referee</code> might print a message after conducting some checks concerning game rules.</li>
</ul>

<p>However, consider that second overload: <code class="language-plaintext highlighter-rouge">makeComment(String)</code>.
In most cases, the job of that method is to simply print the input it has been given.</p>

<p><strong>Do we really want to duplicate that code in each of those three classes?</strong></p>

<p><strong>Enter <code class="language-plaintext highlighter-rouge">default</code> methods</strong>. So far, we have only seen <em>abstract methods</em> in interfaces: methods with <em>declarations</em>, but no <em>definitions</em>. Method <em>signatures</em>, but no <em>bodies</em>.
These methods must be implemented by a subclass, because otherwise the object cannot actually perform that behaviour.</p>

<p>However, interfaces also allow us to define <code class="language-plaintext highlighter-rouge">default</code> methods: these are methods in interfaces that <em>do</em> have implementations.
These implementations are inherited by all implementing subclasses, unless the subclass overrides it.<sup id="fnref:override" role="doc-noteref"><a href="#fn:override" class="footnote" rel="footnote">1</a></sup></p>

<p>Let us consider the <code class="language-plaintext highlighter-rouge">Socializer</code> interface as our illustrative example.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Socializer</span> <span class="o">{</span>
  <span class="kt">void</span> <span class="nf">makeComment</span><span class="o">();</span>

  <span class="k">default</span> <span class="kt">void</span> <span class="nf">makeComment</span><span class="o">(</span><span class="nc">String</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Each of the implementing subclasses (<code class="language-plaintext highlighter-rouge">GreedyPlayer</code>, <code class="language-plaintext highlighter-rouge">Spectator</code>, and <code class="language-plaintext highlighter-rouge">Referee</code>) will inherit the existing <code class="language-plaintext highlighter-rouge">default</code> implementation of the second <code class="language-plaintext highlighter-rouge">makeComment</code> method above.
This means that they only need to implement the first <code class="language-plaintext highlighter-rouge">makeComment()</code> in order to “fully implement” the <code class="language-plaintext highlighter-rouge">Socializer</code> interface.
This is great! It saves us from having to duplicate the second <code class="language-plaintext highlighter-rouge">makeComment(String)</code> method three times.</p>

<p>Of course, they are free to <em>override</em> the <code class="language-plaintext highlighter-rouge">makeComment(String)</code> method if they want to do something different from inherited <code class="language-plaintext highlighter-rouge">default</code> method.</p>

<p>For example, suppose the <code class="language-plaintext highlighter-rouge">Referee</code> wants to print the word <code class="language-plaintext highlighter-rouge">"WHISTLE!"</code> before each comment they print.</p>

<p>In the code below, the <code class="language-plaintext highlighter-rouge">Referee</code> class implements one <code class="language-plaintext highlighter-rouge">makeComment()</code> method because that <em>has to</em> be implemented — it’s abstract in the <code class="language-plaintext highlighter-rouge">Socializer</code> interface.
It also implements the <code class="language-plaintext highlighter-rouge">makeComment(String)</code> method, this time overriding the default behaviour that was inherited from the <code class="language-plaintext highlighter-rouge">Socializer</code> interface.</p>

<p>It prints the word <code class="language-plaintext highlighter-rouge">"WHISTLE!"</code> first.
Then it uses the <code class="language-plaintext highlighter-rouge">super</code> keyword to invoke the parent implementation of the <code class="language-plaintext highlighter-rouge">makeComment(String)</code> method.</p>

<p class="callout">The <code class="language-plaintext highlighter-rouge">super</code> keyword is like the <code class="language-plaintext highlighter-rouge">this</code> keyword, except the object refers to itself <em>as its parent type</em> instead of its own type.
In the example below, the <code class="language-plaintext highlighter-rouge">super.makeComment(message)</code> invokes the <code class="language-plaintext highlighter-rouge">makeComment(String)</code> method from the parent type, i.e., the <code class="language-plaintext highlighter-rouge">Socializer</code> interface.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Referee</span> <span class="kd">implements</span> <span class="nc">Socializer</span> <span class="o">{</span>
  <span class="c1">// Referee's instance variables</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">game</span><span class="o">;</span> <span class="c1">// The Game that is currently being refereed</span>

  <span class="kd">public</span> <span class="nf">Referee</span><span class="o">(</span><span class="nc">Game</span> <span class="n">game</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">game</span> <span class="o">=</span> <span class="n">game</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeComment</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">game</span><span class="o">);</span> <span class="c1">// The referee just reports the Game state</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeComment</span><span class="o">(</span><span class="nc">String</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"WHISTLE! "</span><span class="o">);</span> <span class="c1">// Referee adds its own behaviour here</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">makeComment</span><span class="o">(</span><span class="n">message</span><span class="o">);</span> <span class="c1">// Referee invokes the Socializer's default behaviour</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p class="callout ponder">In the <code class="language-plaintext highlighter-rouge">makeComment(String)</code> method above, what do you think would happen if we called <code class="language-plaintext highlighter-rouge">this.makeComment(message)</code> instead of <code class="language-plaintext highlighter-rouge">super.makeComment(message)</code>?</p>

<h3 id="multiple-conflicting-default-methods">Multiple conflicting default methods</h3>

<p>So far, we have learned the following facts about interfaces in Java:</p>

<ul>
  <li>Interfaces can define abstract methods that <em>must</em> be implemented by subclasses.</li>
  <li>Interfaces can also define “concrete” methods using the <code class="language-plaintext highlighter-rouge">default</code> keyword — these <em>can</em> be overridden by implementing subclasses, or they can be inherited.</li>
  <li>Classes can implement multiple interfaces.</li>
</ul>

<p>With the facts above in mind, consider the following example.</p>

<p>Class <code class="language-plaintext highlighter-rouge">C</code> <code class="language-plaintext highlighter-rouge">implements</code> both interfaces <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code>.
Interfaces <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code> both define the method <code class="language-plaintext highlighter-rouge">doStuff</code> as a <code class="language-plaintext highlighter-rouge">default</code> method, but both do different things.</p>

<pre class="mermaid">
classDiagram
  direction TD

  note "Interfaces <code>A</code> and <code>B</code> both define <code>doStuff</code> as a <code>default</code> method."

  `interface A` &lt;|-- C : implements 
  `interface B` &lt;|-- C : implements 

  class `interface A` {
    +doStuff() void
  }

  class `interface B` {
    +doStuff() void
  }
</pre>

<p class="callout ponder">Which of the two <code class="language-plaintext highlighter-rouge">doStuff</code> behaviours should class <code class="language-plaintext highlighter-rouge">C</code> inherit?</p>

<h3 id="java-doesnt-support-multiple-inheritance">Java doesn’t support multiple inheritance</h3>

<p>In a situation like the above, there is simply no way for the compiler to know <em>which</em> <code class="language-plaintext highlighter-rouge">doStuff</code> method you want to inherit.
So the compiler will show you an error until you give class <code class="language-plaintext highlighter-rouge">C</code> its own implementation of <code class="language-plaintext highlighter-rouge">doStuff</code>.
By implementing its version of the method, there is no ambiguity about which one to inherit—<code class="language-plaintext highlighter-rouge">C</code> inherits neither of the parent interface’s <code class="language-plaintext highlighter-rouge">doStuff</code> implementations.</p>

<p>What if you <em>wanted</em> one of the specific implementations? Do you just duplicate that code? <strong>No.</strong></p>

<p>In that case, you still need to write your own <code class="language-plaintext highlighter-rouge">doStuff</code> method, but in the body of the method, you can invoke the specific parent <code class="language-plaintext highlighter-rouge">doStuff</code> that you want.</p>

<p>So suppose you want the class <code class="language-plaintext highlighter-rouge">C</code>’s <code class="language-plaintext highlighter-rouge">doStuff</code> method to do whatever was defined in <code class="language-plaintext highlighter-rouge">interface A</code>. You do the following:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">C</span> <span class="kd">implements</span> <span class="no">A</span><span class="o">,</span> <span class="no">B</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doStuff</span><span class="o">()</span> <span class="o">{</span>
    <span class="no">A</span><span class="o">.</span><span class="na">super</span><span class="o">.</span><span class="na">doStuff</span><span class="o">();</span> <span class="c1">// Invoke the interface A's version of the method</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="extends-or-implements">extends or implements?</h2>

<p>So we’ve seen two ways of creating fairly complex class structures. We can either create a “tree like” structure, where one interface <code class="language-plaintext highlighter-rouge">extends</code> another interface in order to allow classes to combine those behaviours.
Or we can create a “flatter” structure by creating multiple interfaces; classes that want to combine those behaviours simply need to implement both interfaces.
And <code class="language-plaintext highlighter-rouge">default</code> methods allow us to also introduce some code reuse into this picture.</p>

<p><strong>Interfaces let you create non-hierarchical type frameworks.</strong> Not all class organisations lend themselves to tree structures. That is, you may want different combinations of types “mixed together” for specific subclasses. To achieve this flexibly with <code class="language-plaintext highlighter-rouge">extends</code> relationships, you would end up with many more “intermediate” layers in your type hierarchy, creating a separate type for each combination of functionality you want to support. With interfaces you have infinite flexibility to enhance class behaviours as needed.</p>

<p>However, it is often easier to reason about tree-like structures, because there is less ambiguity about what classes can perform what behaviours.
This “straightline” flow of inherited behaviours can often be a blessing in a large, complex class structure.
If you know you’re not likely to add new classes that support some behaviours but not others, it may be worthwhile to commit to a tree-like structure using <code class="language-plaintext highlighter-rouge">extends</code> for the time being.</p>

<h2 id="summary">Summary</h2>

<p>To sum up, here are some facts about interfaces:</p>

<ul>
  <li>Interfaces can have abstract methods. These only have method signatures, but not method bodies. There is no special keyword for abstract methods in interfaces.</li>
  <li>A class that <code class="language-plaintext highlighter-rouge">implements</code> an interface <em>must</em> include implementations for all abstract methods in a parent interface.</li>
  <li>Interfaces can also have methods that <em>do</em> have implementations. These are created using the <code class="language-plaintext highlighter-rouge">default</code> keyword.</li>
  <li>Implementing subclasses <em>can</em> include implementations for the <code class="language-plaintext highlighter-rouge">default</code> methods from the parent interface; this will override the interface’s <code class="language-plaintext highlighter-rouge">default</code> behaviour for that method.</li>
  <li>Interfaces can have <code class="language-plaintext highlighter-rouge">static</code> variables and <code class="language-plaintext highlighter-rouge">static</code> methods.</li>
  <li>Interfaces <strong>cannot</strong> have instance variables.</li>
  <li>Interfaces can extend other interfaces using the <code class="language-plaintext highlighter-rouge">extends</code> keyword. If a class declares that it <code class="language-plaintext highlighter-rouge">implements</code> an interface, and that interface has “parent” interfaces, the class must implement all abstract methods from the immediate parent as well as all the “grand parent” interfaces.</li>
  <li>Classes can implement more than one interface.</li>
</ul>

<hr />
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:override" role="doc-endnote">
      <p>See the lesson on <a href="../05-method-dispatch/">method dispatch</a> for a review of what is meant by “overriding”. <a href="#fnref:override" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

    </div>
    
    
    <script type="module">
      import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    </script>
    
    </article>
  </main>
</body>
</html>
