<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="x-ua-compatible" content="ie=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-site-verification" content="hIU2NRFm9Pwt76Z9R8DR92m2-kC85IQw6eIS3Ag7y7U" />
  
  <meta name="robots" content="noindex">
  

	<title>Inheritance and equality - Ayaan M. Kazerouni</title>

	<link rel="stylesheet" href="/css/main.css" type="text/css">
  <link rel="stylesheet" href="/assets/academicons/css/academicons.min.css">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.1/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
	<link rel="canonical" href="https://ayaankazerouni.org/courses/csc203/coursenotes/11-inheritance-equality/">
	<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
	<script src="/assets/js/footnote-preview.js" ></script>
</head>



<body>
  <main>
  
  
  
  
  <p>
    (Coursenotes for <a href="/courses/csc203#course-schedule">CSC 203 Project-based Object-oriented Programming and Design</a>)
  </p>
  
  <h1>Inheritance and equality</h1>
  <article>
      <ul id="markdown-toc">
  <li><a href="#plain-old-inheritance" id="markdown-toc-plain-old-inheritance">Plain old inheritance</a></li>
  <li><a href="#tostring" id="markdown-toc-tostring"><code class="language-plaintext highlighter-rouge">toString</code></a>    <ul>
      <li><a href="#tostring-should-not-have-any-side-effects" id="markdown-toc-tostring-should-not-have-any-side-effects"><code class="language-plaintext highlighter-rouge">toString</code> should not have any side-effects!</a></li>
    </ul>
  </li>
  <li><a href="#equals" id="markdown-toc-equals"><code class="language-plaintext highlighter-rouge">equals</code></a></li>
  <li><a href="#inheritance-and-equality" id="markdown-toc-inheritance-and-equality">Inheritance and equality</a>    <ul>
      <li><a href="#closedfigure-equals" id="markdown-toc-closedfigure-equals"><code class="language-plaintext highlighter-rouge">ClosedFigure</code> <code class="language-plaintext highlighter-rouge">equals</code></a></li>
      <li><a href="#circle-equals" id="markdown-toc-circle-equals"><code class="language-plaintext highlighter-rouge">Circle</code> <code class="language-plaintext highlighter-rouge">equals</code></a></li>
      <li><a href="#square-equals" id="markdown-toc-square-equals"><code class="language-plaintext highlighter-rouge">Square</code> <code class="language-plaintext highlighter-rouge">equals</code></a></li>
    </ul>
  </li>
  <li><a href="#some-examples" id="markdown-toc-some-examples">Some examples</a>    <ul>
      <li><a href="#example-1" id="markdown-toc-example-1">Example 1</a></li>
      <li><a href="#example-2" id="markdown-toc-example-2">Example 2</a></li>
      <li><a href="#example-3" id="markdown-toc-example-3">Example 3</a></li>
    </ul>
  </li>
  <li><a href="#summary" id="markdown-toc-summary">Summary</a></li>
</ul>

<h2 id="plain-old-inheritance">Plain old inheritance</h2>

<p>So far, we have seen two ways of using polymorphism in Java: interfaces and abstract classes.
In this lesson we will (briefly) talk about “plain old inheritance”.</p>

<p>In short: it is possible for “regular old classes” to be <code class="language-plaintext highlighter-rouge">extend</code>ed by other classes.
For example, we could have…</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">A</span> <span class="kd">extends</span> <span class="no">B</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">var1</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">A</span><span class="o">(</span><span class="kt">int</span> <span class="n">var1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">var2</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">(</span><span class="n">var2</span><span class="o">);</span> <span class="c1">// Just like abstract classes, we need to invoke the super constructor</span>
    <span class="k">this</span><span class="o">.</span><span class="na">var1</span> <span class="o">=</span> <span class="n">var1</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>…but unlike the examples about abstract classes, <code class="language-plaintext highlighter-rouge">class B</code> is a class <em>in its own right</em>.
It represents an abstraction that can also be used to create objects.</p>

<p>On the other hand, abstract classes help us to avoid code duplication and help us root shared behaviours in a common type, but we cannot create objects from abstract classes.</p>

<p>A common example of this type of inheritance is GUI component libraries.
For example, the Android development framework provides a bunch of classes that can be used for various frontend components, like <code class="language-plaintext highlighter-rouge">Button</code>, <code class="language-plaintext highlighter-rouge">TextArea</code>, or <code class="language-plaintext highlighter-rouge">ListView</code>.</p>

<p>All of these classes are usable components in their own right, and can be used to create objects.
However, it’s likely that an Android app developer would want to create their own specialised versions of these components.
For example, they may want to create a <code class="language-plaintext highlighter-rouge">TextArea</code> that has line numbers.
To do that, they might create a class like:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LineNumberTextArea</span> <span class="kd">extends</span> <span class="nc">TextArea</span> <span class="o">{</span>
  <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>You’ve already seen plain old inheritance through the <code class="language-plaintext highlighter-rouge">Object</code> class.</strong></p>

<p>In the lesson on <a href="../05-method-dispatch/">method dispatch</a>, we saw the following line of code.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
</code></pre></div></div>

<p>The fact that we were able to initialise the <code class="language-plaintext highlighter-rouge">obj</code> variable using the <code class="language-plaintext highlighter-rouge">Object</code> constructor should tell you that <code class="language-plaintext highlighter-rouge">Object</code> is <em>not</em> an abstract class.
And, as we know, all reference types <code class="language-plaintext highlighter-rouge">extend</code> the <code class="language-plaintext highlighter-rouge">Object</code> class, and can inherit or override <code class="language-plaintext highlighter-rouge">Object</code>’s behaviours.</p>

<p>Below are two methods defined in the <code class="language-plaintext highlighter-rouge">Object</code> class that are commonly overridden in subclasses. (There are more, but these two are relevant for this discussion.)</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">public String toString()</code>: Computes and returns a <code class="language-plaintext highlighter-rouge">String</code> representation of the object. For the <code class="language-plaintext highlighter-rouge">Object</code> class, this simply returns the object’s memory address. This (not super useful) behaviour will be inherited by a subclass unless the subclass overrides it by writing its own <code class="language-plaintext highlighter-rouge">toString</code> method.</li>
  <li><code class="language-plaintext highlighter-rouge">public boolean equals(Object other)</code>: Checks if this <code class="language-plaintext highlighter-rouge">Object</code> (the calling object) is logically equal to the <code class="language-plaintext highlighter-rouge">other</code> object. For the <code class="language-plaintext highlighter-rouge">Object</code> class, this method checks if they are the same object (i.e., it is the same as using the <code class="language-plaintext highlighter-rouge">==</code> operator). If a subclass wants to define a more useful <code class="language-plaintext highlighter-rouge">equals</code> method, it must override it.</li>
</ul>

<h2 id="tostring"><code class="language-plaintext highlighter-rouge">toString</code></h2>

<p>The <code class="language-plaintext highlighter-rouge">Object</code> class defines a <code class="language-plaintext highlighter-rouge">toString</code> method whose job it is to return a short, human friendly string representation of the object.
For a plain old <code class="language-plaintext highlighter-rouge">Object</code> which is almost never used directly by developers, this <code class="language-plaintext highlighter-rouge">toString</code> method simply returns the object’s address in memory.
The <code class="language-plaintext highlighter-rouge">Object</code> has no other distinguishing features, so there’s not much more to say about it.</p>

<p><strong>You should always override <code class="language-plaintext highlighter-rouge">toString</code> when you write your own classes.</strong> It’s often useful to have a <code class="language-plaintext highlighter-rouge">toString</code> method for your own classes.
It brings a number of conveniences.</p>

<ol>
  <li>You can simply “print” an object’s info by giving the object as an argument to <code class="language-plaintext highlighter-rouge">System.out.print</code>. The <code class="language-plaintext highlighter-rouge">print</code> method will automatically call <code class="language-plaintext highlighter-rouge">toString</code> on whatever its argument is, if its argument is not a <code class="language-plaintext highlighter-rouge">String</code>. If you don’t write a <code class="language-plaintext highlighter-rouge">toString</code> method, the runtime will simply move up the type hierarchy until it finds a <code class="language-plaintext highlighter-rouge">toString</code> method, and call that instead.<sup id="fnref:polymorphism" role="doc-noteref"><a href="#fn:polymorphism" class="footnote" rel="footnote">1</a></sup></li>
  <li>When you give your object a <code class="language-plaintext highlighter-rouge">toString</code> method, you “buy into” a larger ecosystem of libraries.</li>
</ol>

<p>For example, suppose you’ve created your own custom linked list class, called <code class="language-plaintext highlighter-rouge">MyLinkedList</code>.
For simplicity, let’s say the list contains integers, and you are performing some complex operations on this linked list.</p>

<p>You will hopefully be writing tests to check that your list functions are behaving as expected. E.g., you might write something like this:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Expected value is a list like 1 --&gt; 2 --&gt; 3</span>
<span class="nc">MyLinkedList</span> <span class="n">expected</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyLinkedList</span><span class="o">(</span><span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="kc">null</span><span class="o">)));</span>
<span class="nc">MyLinkedList</span> <span class="n">actual</span> <span class="o">=</span> <span class="o">....</span> <span class="c1">// Assume you have called some complex function here that returns a list</span>
<span class="n">assertEquals</span><span class="o">(</span><span class="n">expected</span><span class="o">,</span> <span class="n">actual</span><span class="o">);</span>
</code></pre></div></div>

<p>If your test passes, all well and good.
However, if your test fails, you’re going to see an error message like this:</p>

<pre><code class="language-txt">Expected: MyLinkedList@eb2184
Actual: MyLinkedList@ai02481
</code></pre>

<p>The JUnit failure message for <code class="language-plaintext highlighter-rouge">assertEquals</code> automatically uses the object’s <code class="language-plaintext highlighter-rouge">toString</code> method to communicate the expected value and actual values to the user.
If you do not write a <code class="language-plaintext highlighter-rouge">toString</code> method, you’re going to get the gibberish above.</p>

<p>If you <em>do</em> write a <code class="language-plaintext highlighter-rouge">toString</code> method, you will get much nicer error messages in JUnit.
For example, assuming you wrote a <code class="language-plaintext highlighter-rouge">toString</code> method that prints out each node’s value with an arrow between them, you would see the following:</p>

<pre><code class="language-txt">Expected: 1 --&gt; 2 --&gt; 3
Actual: 3 --&gt; 2 --&gt; 1
</code></pre>

<p>Much easier to interpret!</p>

<p><strong>In general, IDEs and libraries will use the <code class="language-plaintext highlighter-rouge">toString</code> method whenever they need to refer to an object in text output for a human to read.</strong></p>

<p>Another really important example is the <a href="https://www.jetbrains.com/help/idea/debugging-code.html">debugger in IntelliJ IDEA</a> and most other Java IDEs. When you inspect a variable’s value while debugging, the debugger by default displays the result of calling <code class="language-plaintext highlighter-rouge">toString</code> on that variable.
Without a <code class="language-plaintext highlighter-rouge">toString</code> method for custom classes, you are just going to be given the memory address.</p>

<p>For example, consider the image below, reproduced from <a href="https://www.jetbrains.com/help/idea/debug-tool-window.html#sessions">IntelliJ’s help docs</a>. In the screenshot, the user is inspecting the <code class="language-plaintext highlighter-rouge">this</code> object, which appears to be a <code class="language-plaintext highlighter-rouge">Whale</code> object.
Unfortunately, the <code class="language-plaintext highlighter-rouge">Whale</code> in this example does <em>not</em> have a <code class="language-plaintext highlighter-rouge">toString</code> method, so the user has to expand the <code class="language-plaintext highlighter-rouge">this</code> object to inspect its data.
If the <code class="language-plaintext highlighter-rouge">Whale</code> <em>did</em> have a <code class="language-plaintext highlighter-rouge">toString</code>, that value would be printed instead of <code class="language-plaintext highlighter-rouge">{Whale@784}</code> (the object’s memory address).</p>

<figure>
  <a href="debugger.png" target="_blank">
    
    <img src="debugger.png" alt="" />
    
  </a>

  <figcaption>A screenshot of a debugger session. Notice the 'Whale@784'.</figcaption>
</figure>

<p>A well-written <code class="language-plaintext highlighter-rouge">toString</code> can make this type of debugging go much faster.</p>

<h3 id="tostring-should-not-have-any-side-effects"><code class="language-plaintext highlighter-rouge">toString</code> should not have any side-effects!</h3>

<p>This is a <strong>REALLY IMPORTANT</strong> requirement of <code class="language-plaintext highlighter-rouge">toString</code> methods. A <code class="language-plaintext highlighter-rouge">toString</code> method must <strong>not</strong>, under any circumstances, make changes to an object, or generally have any other effects other than computing and returning a <code class="language-plaintext highlighter-rouge">String</code>.</p>

<p>Because the <code class="language-plaintext highlighter-rouge">toString</code> method is implicitly used by so many libraries, it can lead to really subtle and hard-to-track-down bugs if the <code class="language-plaintext highlighter-rouge">toString</code> method also causes other effects like mutations, or writing to a file.</p>

<p>A real example: In Spring 2023, when I was teaching CSC 305, a student was reading data from a file in their <code class="language-plaintext highlighter-rouge">toString</code> method.
Each file read was triggering a “cache miss counter” which counted how many times the file was read.
This counter was supposed to end up with values within an expected range.
Imagine their surprise when the program worked differently when it was run in debug mode vs. regular mode vs. test mode!
Each use of <code class="language-plaintext highlighter-rouge">toString</code> (whether the student called it themselves or not) caused the counter to trigger — this means that, in addition to normal circumstances, the counter got triggered when a JUnit test case tried to display results, and when the student tried debug their program using the debugger.</p>

<p>I’ll say that again: the act of using the debugger was itself manifesting the bug the student was trying to track down. What a nightmare!</p>

<h2 id="equals"><code class="language-plaintext highlighter-rouge">equals</code></h2>

<p>Next up, we will talk about the <code class="language-plaintext highlighter-rouge">equals</code> method in Java.
All the way in the <a href="../01-intro-java/">first lesson</a>, we talked about how reference types (i.e., objects) must <em>not</em> be checked for equality using the <code class="language-plaintext highlighter-rouge">==</code> operator.
We must instead use the <code class="language-plaintext highlighter-rouge">.equals</code> method.</p>

<p>The <code class="language-plaintext highlighter-rouge">Object</code> class provides an <code class="language-plaintext highlighter-rouge">equals</code> method that all classes inherit, unless they write their own <code class="language-plaintext highlighter-rouge">equals</code> method.
This “fallback” <code class="language-plaintext highlighter-rouge">equals</code> method does the same check as <code class="language-plaintext highlighter-rouge">==</code> — it checks if two variables’ memory addresses are the same.
That is, it checks if they both point to the same object.</p>

<p>Like we’ve seen, this is not super useful. We can write our own <code class="language-plaintext highlighter-rouge">equals</code> method.</p>

<p>The <code class="language-plaintext highlighter-rouge">equals</code> method in the <code class="language-plaintext highlighter-rouge">Object</code> class has the signature: <code class="language-plaintext highlighter-rouge">public boolean equals(Object other)</code>. Notice that it takes an <em><code class="language-plaintext highlighter-rouge">Object</code></em> as a parameter—it has to, because as far as <code class="language-plaintext highlighter-rouge">Object</code> is concerned, no other classes exist.</p>

<p>This means that when we override <code class="language-plaintext highlighter-rouge">equals</code> in a subclass, even the subclass’s <code class="language-plaintext highlighter-rouge">equals</code> method needs to take an <code class="language-plaintext highlighter-rouge">Object</code> as a parameter.</p>

<p>Every <code class="language-plaintext highlighter-rouge">equals</code> method must do the following checks.</p>

<ol>
  <li>Check if the incoming object is <code class="language-plaintext highlighter-rouge">null</code>. If it is <code class="language-plaintext highlighter-rouge">null</code>, then we cannot be equal to it, so return <code class="language-plaintext highlighter-rouge">false</code> and quit.
    <ul>
      <li>This step is necessary because we need the object to actually exist in order to check its type.</li>
    </ul>
  </li>
  <li>Check if the incoming object has the same type as our <code class="language-plaintext highlighter-rouge">this</code> object. If it does not, then we cannot be equal to it, so return <code class="language-plaintext highlighter-rouge">false</code> and quit.
    <ul>
      <li>This step is necessary because we need the types to match to be able to cast the incoming object to the <code class="language-plaintext highlighter-rouge">this</code> object’s type. Because the parameter type is declared to be <code class="language-plaintext highlighter-rouge">Object</code>, you can call any <code class="language-plaintext highlighter-rouge">equals</code> with pretty much <em>any</em> parameter. We don’t want nasty runtime errors because of that.</li>
    </ul>
  </li>
  <li>If the types match, cast the incoming object to our type, so that we can access its data.
    <ul>
      <li>This step is needed because we can’t access the data we’re interested in from the incoming object while its static type is still <code class="language-plaintext highlighter-rouge">Object</code>.</li>
    </ul>
  </li>
  <li>Compare the fields you need to compare to determine equality.
    <ul>
      <li>This step is necessary for, well, checking equality.</li>
    </ul>
  </li>
</ol>

<p>The <code class="language-plaintext highlighter-rouge">equals</code> method is a regrettably clunky bit of tedium baked into the Java language.
Arguably, only step 4 above is germane to the task of deciding whether two objects are equal — all the other steps are just us fighting with the type and inheritance systems to be able to actually compare the data we want to compare.
Unfortunately, as described above, all the steps are necessary or we risk runtime exceptions.
So it goes.</p>

<p>Luckily, most IDEs can generate an equals method for you if you have a class that contains instance variables.</p>

<p>See the <code class="language-plaintext highlighter-rouge">Person</code> class below for an example.
It contains two instance variables: <code class="language-plaintext highlighter-rouge">name</code> and <code class="language-plaintext highlighter-rouge">age</code>, and an <code class="language-plaintext highlighter-rouge">equals</code> method that considers two <code class="language-plaintext highlighter-rouge">Person</code> objects “equal” if they have equal names and equal ages.</p>

<p>Use the “Walkthrough” button to see how each check that was described above is carried out.</p>

<p>
<div style="width: 100%; margin: auto;">
  <a href="Person.html" target="_blank">
    <small>
      View in new tab
    </small>
  </a>
  <br />
  <object data="Person.html" width="100%" height="700px"></object>
</div>
</p>

<p><strong>You should always write an <code class="language-plaintext highlighter-rouge">equals</code> method for any class that you create.</strong>
Like the <code class="language-plaintext highlighter-rouge">toString</code> method, this buys you into a larger set of libraries.
For example:</p>

<ul>
  <li>The JUnit <code class="language-plaintext highlighter-rouge">assertEquals</code> method uses the <code class="language-plaintext highlighter-rouge">equals</code> method to check if its two arguments are equal.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Point</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
<span class="nc">Point</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>

<span class="n">assertEquals</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">);</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">assertEquals</code> above is equivalent to doing <code class="language-plaintext highlighter-rouge">assertTrue(a.equals(b))</code>.
That is, <code class="language-plaintext highlighter-rouge">assertEquals</code> calls the <code class="language-plaintext highlighter-rouge">equals</code> method of the first argument, using the second argument as the input.
If you do <em>not</em> write an <code class="language-plaintext highlighter-rouge">equals</code> method, the test above will fail, because it will be checking <em>sameness</em>, not equality.</p>

<ul>
  <li>Java collections use the <code class="language-plaintext highlighter-rouge">equals</code> method for things like checking if a list contains an object, etc.</li>
</ul>

<p>Suppose you had the following <code class="language-plaintext highlighter-rouge">List&lt;Person&gt;</code>, and it contained some <code class="language-plaintext highlighter-rouge">Person</code> objects.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Person</span><span class="o">&gt;</span> <span class="n">people</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span>
   <span class="k">new</span> <span class="nf">Person</span><span class="o">(</span><span class="s">"Joe Bro"</span><span class="o">,</span> <span class="mi">29</span><span class="o">),</span>
   <span class="k">new</span> <span class="nf">Person</span><span class="o">(</span><span class="s">"Pooja Ahuja"</span><span class="o">,</span> <span class="mi">31</span><span class="o">)</span>
<span class="o">);</span>
</code></pre></div></div>

<p>Then, suppose in another function, you need to check if <code class="language-plaintext highlighter-rouge">"Pooja Ahuja"</code> exists in this list.
You would use the list’s <code class="language-plaintext highlighter-rouge">contains</code> function to do this check.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Person</span> <span class="n">pa</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Pooja Ahuja"</span><span class="o">,</span> <span class="mi">31</span><span class="o">);</span>
<span class="n">assertTrue</span><span class="o">(</span><span class="n">people</span><span class="o">.</span><span class="na">list</span><span class="o">(</span><span class="n">contains</span><span class="o">(</span><span class="n">pa</span><span class="o">)));</span> <span class="c1">// Will this test pass or fail?</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">contains</code> method loops over the items in the <code class="language-plaintext highlighter-rouge">people</code> list, and checks if each one <code class="language-plaintext highlighter-rouge">equals</code> the <code class="language-plaintext highlighter-rouge">pa</code> object.
If you do <em>not</em> give <code class="language-plaintext highlighter-rouge">Person</code> an <code class="language-plaintext highlighter-rouge">equals</code> method, it will default to inherited <code class="language-plaintext highlighter-rouge">equals</code> behaviour, i.e., it will check whether any item in the list is the <em>same</em> object as the one that <code class="language-plaintext highlighter-rouge">pa</code> points to.
This means the test above will fail.</p>

<p>If you <em>do</em> write an <code class="language-plaintext highlighter-rouge">equals</code> method for <code class="language-plaintext highlighter-rouge">Person</code>, the <code class="language-plaintext highlighter-rouge">contains</code> method does a much more logical check for equality—it checks each person in the <code class="language-plaintext highlighter-rouge">people</code> list and returns <code class="language-plaintext highlighter-rouge">true</code> if it finds a <code class="language-plaintext highlighter-rouge">Person</code> with the same name and age as <code class="language-plaintext highlighter-rouge">pa</code>.</p>

<h2 id="inheritance-and-equality">Inheritance and equality</h2>

<p>…or, why we don’t use <code class="language-plaintext highlighter-rouge">instanceof</code> in the type check of an <code class="language-plaintext highlighter-rouge">equals</code> method.</p>

<p>Notice that in the <code class="language-plaintext highlighter-rouge">equals</code> method above, we are doing the type check using <code class="language-plaintext highlighter-rouge">this.getClass().equals(other.getClass())</code> and not <code class="language-plaintext highlighter-rouge">other instanceof Person</code>.
The <code class="language-plaintext highlighter-rouge">getClass</code> method is inherited from <code class="language-plaintext highlighter-rouge">Object</code>, and returns the dynamic type of the calling object.</p>

<p class="callout">Comparing the <em>class</em> of two objects lets you do an <em>exact match</em> comparison.
So if <code class="language-plaintext highlighter-rouge">this</code> is a <code class="language-plaintext highlighter-rouge">Person</code> object, the boolean expression <code class="language-plaintext highlighter-rouge">this.getClass().equals(other.getClass())</code> will be <code class="language-plaintext highlighter-rouge">true</code> if and only if <code class="language-plaintext highlighter-rouge">other</code> is also a <code class="language-plaintext highlighter-rouge">Person</code> object.
On the other hand, the boolean expression <code class="language-plaintext highlighter-rouge">other instanceof Person</code> will be <code class="language-plaintext highlighter-rouge">true</code> if <code class="language-plaintext highlighter-rouge">other</code> is a <code class="language-plaintext highlighter-rouge">Person</code> object or if it is some subtype of <code class="language-plaintext highlighter-rouge">Person</code>.</p>

<p>Let’s see an example of how this can go wrong.</p>

<p>Consider the following type hierarchy.</p>

<ul>
  <li>We have a <code class="language-plaintext highlighter-rouge">ClosedFigure</code> that has a <code class="language-plaintext highlighter-rouge">location</code>, a getter and setter method for it, and an <code class="language-plaintext highlighter-rouge">equals</code> method (two <code class="language-plaintext highlighter-rouge">ClosedFigure</code>s are considered equal if they have equal locations).</li>
  <li>We have a <code class="language-plaintext highlighter-rouge">Circle</code> that extends <code class="language-plaintext highlighter-rouge">ClosedFigure</code> and additionally has a <code class="language-plaintext highlighter-rouge">radius</code>. Two <code class="language-plaintext highlighter-rouge">Circle</code>s are considered equal if they have equal radii <em>and</em> locations.</li>
  <li>We have a <code class="language-plaintext highlighter-rouge">Square</code> that extends <code class="language-plaintext highlighter-rouge">ClosedFigure</code> and additionally has a <code class="language-plaintext highlighter-rouge">side</code> length. Two <code class="language-plaintext highlighter-rouge">Square</code>s are considered equal if they have equal side lengths <em>and</em> locations.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">Circle</code> and <code class="language-plaintext highlighter-rouge">Square</code> each have their own override of <code class="language-plaintext highlighter-rouge">ClosedFigure</code>’s <code class="language-plaintext highlighter-rouge">equals</code> method.
None of these classes are abstract.</p>

<pre class="mermaid">
classDiagram
   direction LR

   ClosedFigure &lt;-- Circle : extends
   ClosedFigure &lt;-- Square : extends

   class ClosedFigure {
      -Point location
      location() Point
      moveTo(Point) void
      toString() String
      equals(Object) boolean
   }

   class Circle {
      -int radius
      radius() int
      equals(Object) boolean
   }

   class Square {
      -int side
      side() int
      equals(Object) boolean
   }
</pre>

<p>Let’s take a look at the <code class="language-plaintext highlighter-rouge">equals</code> methods for these three classes.</p>

<h3 id="closedfigure-equals"><code class="language-plaintext highlighter-rouge">ClosedFigure</code> <code class="language-plaintext highlighter-rouge">equals</code></h3>

<p>The code below shows an <code class="language-plaintext highlighter-rouge">equals</code> method for the <code class="language-plaintext highlighter-rouge">ClosedFigure</code> class.
Two <code class="language-plaintext highlighter-rouge">ClosedFigure</code>s are considered equal if they have the same location.</p>

<p>This is pretty standard, just like we saw for the <code class="language-plaintext highlighter-rouge">Person</code> example above.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">other</span><span class="o">)</span> <span class="o">{</span>
   <span class="k">if</span> <span class="o">(</span><span class="n">other</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
   <span class="o">}</span>

   <span class="k">if</span> <span class="o">(</span><span class="n">getClass</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">other</span><span class="o">.</span><span class="na">getClass</span><span class="o">()))</span> <span class="o">{</span>
      <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
   <span class="o">}</span>
      
   <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">location</span><span class="o">.</span><span class="na">equals</span><span class="o">(((</span><span class="nc">ClosedFigure</span><span class="o">)</span> <span class="n">other</span><span class="o">).</span><span class="na">location</span><span class="o">);</span> 
<span class="o">}</span>
</code></pre></div></div>

<h3 id="circle-equals"><code class="language-plaintext highlighter-rouge">Circle</code> <code class="language-plaintext highlighter-rouge">equals</code></h3>

<p>Two <code class="language-plaintext highlighter-rouge">Circle</code>s are considered equal if they have the same radii <em>and</em> they have the same location.
Now, we could easily copy the <code class="language-plaintext highlighter-rouge">equals</code> method from above and just add an <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> to that last return statement to also check the radii of the circles.
But that would be code duplication, and we don’t want that.</p>

<p>Instead, since <code class="language-plaintext highlighter-rouge">Circle extends ClosedFigure</code>, we can use that inheritance relationship so re-use <code class="language-plaintext highlighter-rouge">ClosedFigure</code>’s equals method for the location check (and really, all the other checks except the radius check).</p>

<p>In the code below, there is no null check or type check—those checks are already being taken care of by the <code class="language-plaintext highlighter-rouge">ClosedFigure</code> class.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">other</span><span class="o">){</span>
   <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">other</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">radius</span> <span class="o">==</span> <span class="o">((</span><span class="nc">Circle</span><span class="o">)</span> <span class="n">other</span><span class="o">).</span><span class="na">radius</span><span class="o">;</span>      
<span class="o">}</span>  
</code></pre></div></div>

<p>The compound boolean expression in the return statement above will “short circuit” if the first condition is <code class="language-plaintext highlighter-rouge">false</code>.
That is, if <code class="language-plaintext highlighter-rouge">super.equals(other)</code> is <code class="language-plaintext highlighter-rouge">false</code>, the rest of the condition doesn’t matter, so it just won’t be checked.</p>

<h3 id="square-equals"><code class="language-plaintext highlighter-rouge">Square</code> <code class="language-plaintext highlighter-rouge">equals</code></h3>

<p>Similarly, the <code class="language-plaintext highlighter-rouge">Square</code>’s equals method can be simplified by re-using the <code class="language-plaintext highlighter-rouge">equals</code> method from the parent class.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">other</span><span class="o">){</span>
   <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">other</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">side</span> <span class="o">==</span> <span class="o">((</span><span class="nc">Square</span><span class="o">)</span> <span class="n">other</span><span class="o">).</span><span class="na">side</span><span class="o">;</span>      
<span class="o">}</span>  
</code></pre></div></div>

<h2 id="some-examples">Some examples</h2>

<p>Because the <code class="language-plaintext highlighter-rouge">ClosedFigure</code> equals method uses <code class="language-plaintext highlighter-rouge">getClass</code> for the type check, <a href="../05-method-dispatch/">dynamic dispatch</a> takes care of getting the right class name at run time.</p>

<p>So even if you created an object like so:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create a circle with location and radius</span>
<span class="nc">ClosedFigure</span> <span class="n">fig</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Circle</span><span class="o">(</span><span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="mi">10</span><span class="o">);</span>
</code></pre></div></div>

<p>If you called <code class="language-plaintext highlighter-rouge">fig.getClass()</code>, you would <code class="language-plaintext highlighter-rouge">Circle</code> in return, not <code class="language-plaintext highlighter-rouge">ClosedFigure</code>.</p>

<h3 id="example-1">Example 1</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ClosedFigure</span> <span class="n">fig</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Circle</span><span class="o">(</span><span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="mi">10</span><span class="o">);</span>
<span class="nc">Circle</span> <span class="n">fig2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Circle</span><span class="o">(</span><span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="mi">10</span><span class="o">);</span>
</code></pre></div></div>

<p class="callout ponder">What would <code class="language-plaintext highlighter-rouge">fig.equals(fig2)</code> return in the code above?</p>

<p>Here is what happens:</p>

<ol>
  <li>In the code above, dynamic dispatch would call <code class="language-plaintext highlighter-rouge">Circle'</code>s equals method, with <code class="language-plaintext highlighter-rouge">fig</code> as the calling object (i.e., <code class="language-plaintext highlighter-rouge">this</code>).</li>
  <li><code class="language-plaintext highlighter-rouge">Circle</code>’s equals method will in turn call <code class="language-plaintext highlighter-rouge">ClosedFigure</code>’s equals method.</li>
  <li>In <code class="language-plaintext highlighter-rouge">ClosedFigure</code>’s equals method, we move past the <code class="language-plaintext highlighter-rouge">null</code> check, since <code class="language-plaintext highlighter-rouge">fig2</code> is not null.</li>
  <li>We also move past the type check, because <code class="language-plaintext highlighter-rouge">this.getClass()</code> returns <code class="language-plaintext highlighter-rouge">Circle</code>, and <code class="language-plaintext highlighter-rouge">other.getClass()</code> also returns <code class="language-plaintext highlighter-rouge">Circle</code>, because of dynamic dispatch. Even though we are tracing code in the <code class="language-plaintext highlighter-rouge">ClosedFigure</code> class, the <em>calling object</em> is a <code class="language-plaintext highlighter-rouge">Circle</code> at run time.</li>
  <li>Since the type check passed, we cast <code class="language-plaintext highlighter-rouge">other</code> to a <code class="language-plaintext highlighter-rouge">ClosedFigure</code> and check its location. That check will pass, since both locations are <code class="language-plaintext highlighter-rouge">(2, 2)</code>.</li>
  <li>Finally, we come back to the <code class="language-plaintext highlighter-rouge">Circle</code> class, cast <code class="language-plaintext highlighter-rouge">other</code> to a <code class="language-plaintext highlighter-rouge">Circle</code> and compare radii.</li>
</ol>

<h3 id="example-2">Example 2</h3>

<p>Suppose in our <code class="language-plaintext highlighter-rouge">ClosedFigure</code> class, we had used <code class="language-plaintext highlighter-rouge">instanceof</code> instead of <code class="language-plaintext highlighter-rouge">getClass</code>. That is, the type check was carried out using <code class="language-plaintext highlighter-rouge">other instanceof ClosedFigure</code>.</p>

<p class="callout ponder">Looking at the same example as above, what would the outcome of <code class="language-plaintext highlighter-rouge">fig.equals(fig2)</code> be?</p>

<p><strong>There would be no change</strong>. At the moment of the type check, we would check if <code class="language-plaintext highlighter-rouge">other instanceof ClosedFigure</code>. <code class="language-plaintext highlighter-rouge">other</code> is a <code class="language-plaintext highlighter-rouge">Circle</code>, which <em>is a</em> <code class="language-plaintext highlighter-rouge">ClosedFigure</code>. So everything is okay, and our type casts go through without a problem.</p>

<h3 id="example-3">Example 3</h3>

<p>Finally, think about the following example:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Circle</span> <span class="n">circle</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Circle</span><span class="o">(</span><span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="mi">10</span><span class="o">);</span>
<span class="nc">Square</span> <span class="n">square</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Square</span><span class="o">(</span><span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="mi">23</span><span class="o">);</span>

<span class="n">assertTrue</span><span class="o">(</span><span class="n">circle</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">square</span><span class="o">));</span>
</code></pre></div></div>

<p class="callout ponder">What would outcome of <code class="language-plaintext highlighter-rouge">fig.equals(fig2)</code> be? Would it be different using <code class="language-plaintext highlighter-rouge">getClass</code> vs. <code class="language-plaintext highlighter-rouge">instanceof</code> in the <code class="language-plaintext highlighter-rouge">ClosedFigure</code> type check?</p>

<p>Let’s trace the call <code class="language-plaintext highlighter-rouge">circle.equals(square)</code>.</p>

<ol>
  <li>First, we call the <code class="language-plaintext highlighter-rouge">Circle</code> <code class="language-plaintext highlighter-rouge">equals</code> method. That immediately calls the superclass’s <code class="language-plaintext highlighter-rouge">equals</code> method.</li>
  <li>In the superclass equals method (<code class="language-plaintext highlighter-rouge">ClosedFigure::equals</code>), we first check if the argument is <code class="language-plaintext highlighter-rouge">null</code>. It is not (<code class="language-plaintext highlighter-rouge">square</code> was initialised in this example), so we move on.</li>
  <li>Next, we check the type. Let’s think about what happens if we use <code class="language-plaintext highlighter-rouge">instanceof</code> here vs. <code class="language-plaintext highlighter-rouge">getClass</code>. If the check was <code class="language-plaintext highlighter-rouge">other instanceof ClosedFigure</code>: yes, <code class="language-plaintext highlighter-rouge">square</code> is an instance of <code class="language-plaintext highlighter-rouge">ClosedFigure</code>, because of the inheritance relationship between <code class="language-plaintext highlighter-rouge">Square</code> and <code class="language-plaintext highlighter-rouge">ClosedFigure</code>. So move past this check.</li>
  <li>Because the type check was good, we do the type-cast. This is also fine.</li>
  <li>The <code class="language-plaintext highlighter-rouge">location</code> check also passes, because <code class="language-plaintext highlighter-rouge">circle</code> and <code class="language-plaintext highlighter-rouge">square</code> are both at the location <code class="language-plaintext highlighter-rouge">(2, 2)</code> in this example.</li>
  <li>The <code class="language-plaintext highlighter-rouge">ClosedFigure</code> <code class="language-plaintext highlighter-rouge">equals</code> method returns <code class="language-plaintext highlighter-rouge">true</code>, because all the <code class="language-plaintext highlighter-rouge">ClosedFigure</code> stuff was equal! We bounce back to the rest of the <code class="language-plaintext highlighter-rouge">Circle</code> <code class="language-plaintext highlighter-rouge">equals</code> method.</li>
  <li>Because the <code class="language-plaintext highlighter-rouge">super.equals(other)</code> part passed, we check the right-hand-side of the compound <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> expression.</li>
  <li><strong>At this point, our code will crash</strong>. We attempt to cast <code class="language-plaintext highlighter-rouge">other</code> to a <code class="language-plaintext highlighter-rouge">Circle</code>, but <code class="language-plaintext highlighter-rouge">other</code> is a <code class="language-plaintext highlighter-rouge">Square</code>!</li>
</ol>

<p>This mismatch only occurs if in the <code class="language-plaintext highlighter-rouge">ClosedFigure</code> equals method, we use <code class="language-plaintext highlighter-rouge">instanceof</code> to check the type. The <code class="language-plaintext highlighter-rouge">Square</code> <em>is</em> an instance of <code class="language-plaintext highlighter-rouge">ClosedFigure</code>, so even though the two objects are of different types, our equality check doesn’t quit at that line.
This is why we use <code class="language-plaintext highlighter-rouge">getClass</code> to perform the type check in an <code class="language-plaintext highlighter-rouge">equals</code> method.</p>

<h2 id="summary">Summary</h2>

<p>In 99% of cases, you should use <code class="language-plaintext highlighter-rouge">instanceof</code> for type-checking in Java (though if you are doing a lot of type-checking yourself, you should step back and consider your object-oriented design). In <code class="language-plaintext highlighter-rouge">equals</code> methods, where we need an <em>exact accounting</em> of the differences between two objects, we need to use <code class="language-plaintext highlighter-rouge">getClass</code> if we want two objects with the same parent equals method to be treated differently.</p>

<p>Of course, our other option is to perform the type checks in each subclass in addition to the superclass — if you do that, you can use <code class="language-plaintext highlighter-rouge">instanceof</code> as usual, because the equals method will appropriately fail at the subclass’s type check.</p>

<p>You might say that this code duplication is tiresome, but…so is the <code class="language-plaintext highlighter-rouge">equals</code> method.</p>

<hr />

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:polymorphism" role="doc-endnote">
      <p>This is a good example of polymorphism. The <code class="language-plaintext highlighter-rouge">System.out.print</code> method asks for an <code class="language-plaintext highlighter-rouge">Object</code> as a parameter. The actual argument its given might be <em>any type</em>, as long as it’s a subtype of <code class="language-plaintext highlighter-rouge">Object</code>. All the <code class="language-plaintext highlighter-rouge">print</code> method cares about is that its input can produce a string representation of itself, i.e., it can call <code class="language-plaintext highlighter-rouge">toString</code>. <a href="#fnref:polymorphism" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

      <footer class="nav-links">
        
        <a href="/courses/csc203/coursenotes/10-abstract-classes/" class="previous">&larr; Previous</a>
        
        
        <a href="/courses/csc203/coursenotes/12-hashcode/" class="next">Next &rarr;</a>
        
      </footer  >
  </article>
  
  
  <script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';

    const mql = window.matchMedia('(prefers-color-scheme: dark)');
    if (mql.matches) {
      mermaid.initialize({
        theme: 'dark'
      });
    } else {
      mermaid.initialize({
        theme: 'default'
      });
    }
  </script>
  
  </main>
</body>
</html>
