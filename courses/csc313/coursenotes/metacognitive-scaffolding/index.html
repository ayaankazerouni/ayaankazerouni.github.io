<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="x-ua-compatible" content="ie=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-site-verification" content="hIU2NRFm9Pwt76Z9R8DR92m2-kC85IQw6eIS3Ag7y7U" />
  
  <meta name="robots" content="noindex">
  

	<title>Metacognitive scaffolding - Ayaan M. Kazerouni</title>

	<link rel="stylesheet" href="/css/main.css" type="text/css">
  <link rel="stylesheet" href="/assets/academicons/css/academicons.min.css">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.1/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
	<link rel="canonical" href="https://ayaankazerouni.org/courses/csc313/coursenotes/metacognitive-scaffolding/">
	<script src="/assets/js/footnote-preview.js" ></script>
</head>



<body>
  <main>
  
  
  
  <p>
  <a href="/courses/csc313/coursenotes">Coursenotes index</a> | <a href="/courses/csc313/winter2025">CSC 313 Teaching Computing</a> |
  <a href="/teaching">Ayaan M. Kazerouni <i class="fa fa-sign-out-alt"></i></a>
  </p>
  
  <div class="nav-links">
    
    <a href="/courses/csc313/coursenotes/learning-a-second-programming-language/">&larr; Previous</a>
    
    
    <a href="/courses/csc313/coursenotes/spatial-skills/">Next &rarr;</a>
    
  </div>
  <h1>Metacognitive scaffolding</h1>
  <article>
      <ul class="callout readings">
  <li>[1] <a href="http://dl.acm.org/citation.cfm?doid=3230977.3230981">Metacognitive Difficulties Faced by Novice Programmers in Automated Assessment Tools</a> by Prather, Pettit, McMurry, Peters, Homer, &amp; Cohen</li>
  <li>[2] <a href="http://dl.acm.org/citation.cfm?doid=3287324.3287374">First Things First: Providing Metacognitive Scaffolding for Interpreting Problem Prompts</a> by Prather, Pettit, Becker, Denny, Loksa, Peters, Albrecht, &amp; Masci</li>
  <li>[3] <a href="http://doi.acm.org/10.1145/3291279.3339416">Executable Examples for Programming Problem Comprehension</a> by Wrenn &amp; Krishnamurthi</li>
</ul>

<h2 id="metacognitive-awareness">Metacognitive awareness</h2>

<p>We’ve talked a lot this quarter about various aspects of teaching and learning programming: syntax, behaviour, cognition and memory, managing motivation and self-efficacy, and sense of belonging.</p>

<p>Researchers and educators are increasingly starting to focus on an additional aspect: <em>metacognitive awareness</em>, particularly as it relates to problem-solving in programming.</p>

<p>Having metacognitive awareness means knowing where one is in the problem-solving process, being aware of strategies that have been successful or unsuccessful in the past, and monitoring one’s self-efficacy and emotions. This is surprisingly difficult to do!</p>

<p>Novice programmers often lack this ability to think about and reflect on their problem-solving process, and lack the vocabulary to articulate it to a peer or instructor. This can cause all sorts of trouble: without knowledge of a systematic problem-solving process (and without knowledge of one’s own progress through that process), a novice can flounder while solving a programming problem without knowing where their difficulties lie, and can even have difficulties seeking help to overcome those difficulties.</p>

<p>To overcome this, instructors often explicitly teach problem-solving strategies. For example, consider the Design Recipe from <em><a href="https://htdp.org/">How to Design Programs</a></em>:</p>

<ol>
  <li>Identifying the types of data needed for a function to solve a problem</li>
  <li>Write down the function signature and statement of purpose</li>
  <li>Provide some functional examples to illustrate the function’s purpose</li>
  <li>Sketch out the function with a template</li>
  <li>Implement the function</li>
  <li>Test the function</li>
</ol>

<p>Similarly, Loksa et al.<sup id="fnref:loksa" role="doc-noteref"><a href="#fn:loksa" class="footnote" rel="footnote">1</a></sup> propose the following six-step problem-solving process:</p>

<ol>
  <li>Reinterpret the problem prompt</li>
  <li>Search for analogous problems</li>
  <li>Search for solutions</li>
  <li>Evaluate a potential solution</li>
  <li>Implement a solution</li>
  <li>Evaluate implemented solution</li>
</ol>

<p>When these processes are taught, students are often asked to identify where they are in the process before receiving help from instructors. Additionally, they may only be given help up to and including their current step. For example, a student may not receive help with implementing a function (step 5 in both processes above) if they have skipped the steps to understand and concretise the function’s purpose (steps 1—4).</p>

<p><strong>The highest-performing novices tend to display higher metacognitive awareness about their problem-solving and learning strategies.</strong></p>

<h2 id="feedback-in-cs-courses">Feedback in CS courses</h2>

<p>CS students often receive feedback about their program submissions from automated assessment tools (AATs). Feedback can focus on</p>

<ul>
  <li>Syntax (e.g., compiler error messages, which can often be inscrutable, frustrating, and demotivating to novices)</li>
  <li>Behaviour (e.g., instructor-written reference tests)</li>
  <li>Programming standards (using linting tools or manual checking)</li>
  <li>Thoroughness and validity of student-written tests (using test adequacy criteria like condition coverage or, rarely, mutation analysis)</li>
</ul>

<p>In this way, most AATs only attend to steps 5 and 6 of the Design Recipe (and equivalent steps in Loksa’s steps). There is little focus on steps 1–4, i.e., limited feedback to help promote metacognitive awareness, or to nudge students to reflect on their problem-solving process.</p>

<p>Worse, other factors can come into play that may <em>encourage</em> bad habits. For example, many AATs support unlimited submissions so students can receive rapid feedback. While frequent feedback can be a good thing, this can encourage a trial-and-error approach to programming, where students come to rely on the AAT as the oracle to test their programs.</p>

<p class="callout ponder">You’ve likely had plenty of experience with auto-graders. In what ways have they been helpful? Do you see opportunities for improvement?</p>

<h3 id="how-can-automated-assessment-tools-support-metacognitive-awareness">How can automated assessment tools support metacognitive awareness?</h3>

<p>In paper [1], Prather et al. study how AATs could be built to better promote metacognitive awareness in novices.</p>

<p>The researchers conducted a number of one-on-one meetings with students and asked them to  work on a “moderately challenging” programming problem while thinking out loud, i.e., verbalising their thought process as they worked on the problem. They were given 35 minutes to write a function that, given <em>n</em> numbers, would compute whether there were more positive or negative integers given as input. The researcher took extensive notes as the student solved the programming problem.</p>

<p><strong>Students who completed the problem</strong></p>

<p>These students almost universally started with step 1 in Loksa’s process—<em>reinterpret the problem prompt.</em> They formed and verbalised a conceptual model of what the problem was asking for before starting to design a solution. These students also more or less followed the steps in the problem-solving process.</p>

<p>Some students took a long time to complete the problem. They started by interpreting the problem prompt, and got tripped up at some later stage of the problem-solving process.</p>

<p>Two students tried to solve the problem of <em>counting the number of even and odd integers</em> instead of <em>counting the number of positive and negative integers.</em> (It should be noted that the even/odd problem had been asked before and was familiar to them.)
These students didn’t immediately realise that they were <em>solving the wrong problem,</em> and grew increasingly frustrated as they failed to pass the test cases.</p>

<p>Eventually, they would re-read the prompt, realise their mistake, and very quickly solve the problem.
The lack of metacognitive awareness <em>almost</em> kept otherwise capable students from succeeding, and the AAT’s feedback did not alert them to the issue at all.</p>

<p><strong>Students who did not complete the problem</strong></p>

<p>These students failed to successfully move through the problem-solving steps. The most frequent issue for these students was that they failed to build a conceptual model of the problem. The immediately moved to <em>identifying analogous problems</em> and <em>searching for solutions,</em> and the AAT was not able to alert them that they had a wrong conceptual model.</p>

<h4 id="type-of-metacognitive-difficulties-faced-when-working-with-an-aat">Type of metacognitive difficulties faced when working with an AAT</h4>

<p>To sum up, the authors noticed the following metacognitive difficulties the students faced when dealing with feedback from an AAT:</p>

<ul>
  <li>Forming a wrong conceptual model about the right problem</li>
  <li>Dislodging an incorrect conceptual problem may not be solved by re-reading the prompt</li>
  <li>Making assumptions; forming the correct conceptual model for the wrong problem</li>
  <li>Moving too quickly through the stages leads to a false sense of accomplishment</li>
  <li>Unwillingness to abandon a wrong solution due to a false sense of nearly being done<sup id="fnref:false-progress" role="doc-noteref"><a href="#fn:false-progress" class="footnote" rel="footnote">2</a></sup></li>
</ul>

<h3 id="metacognitive-scaffolding-for-problem-comprehension">Metacognitive scaffolding for problem comprehension</h3>

<p>Importantly, 3 of the difficulties above are related to problem comprehension, i.e., <em>understanding what is being asked for.</em> That is, they are related to</p>

<ul>
  <li>Step 1 in Loksa’s problem-solving process (<em>reinterpret the problem prompt</em>), and</li>
  <li>Step 3 in the Design Recipe (<em>design functional examples to illustrate the problem’s purpose</em>).</li>
</ul>

<p>Therefore, these same authors introduced a simple intervention to target problem comprehension [2]. The intervention is as follows:</p>

<ul>
  <li>Students were given the problem prompt</li>
  <li><em>They were then given a test case to solve immediately after reading the problem prompt</em></li>
  <li>Then they were asked to solve the problem</li>
</ul>

<p>That simple intervention—asking the student to demonstrate that they’ve understood the problem prompt by predicting a working program’s output for some given input—had significant impacts on students’ abilities to complete the problem, compared to students who did not receive the intervention.</p>

<p>Compared to a control group, the students who received the intervention:</p>

<ul>
  <li>were more likely to complete the problem (76.19% vs. 52.94%)</li>
  <li>completed the problem slightly faster (22.62 minutes vs. 23.92 minutes on average)</li>
  <li>required fewer submissions to do so (4.48 submissions vs. 7.59 submissions on average)</li>
</ul>

<p class="callout ponder">What do you suppose are the reasons for these results?</p>

<h2 id="automated-scaffolding-for-problem-comprehension">“Automated” scaffolding for problem comprehension</h2>

<p>In separate but related work, Wrenn &amp; Krishamurthi [3] introduced a feature in their pedagogic IDE, giving students tooling to attend to the <em>Examples</em> step of the Design Recipe. The feature works as follows.</p>

<p>Programming assignments are distributed inside the pedagogic IDE <strong><a href="code.pyret.org">code.pyret.org</a></strong>. The assignments come with</p>

<ul>
  <li><em>Wheats:</em> correct solutions implemented by the instructors; wheats would vary in terms of how they implemented underspecified requirements</li>
  <li><em>Chaffs:</em> buggy solutions implemented by the instructors; the buggy solutions are curated so that they represent bugs that could plausibly appear in student solutions</li>
</ul>

<p>For example, if a problem asked students to compute the median of a given list of integers,</p>

<ul>
  <li>Wheats would include implementations that treat even-sized lists of numbers differently. That is, in a sorted list of 4 items, some median calculations would take the second item as the median, while others would take the average of the second and third items as the median.</li>
  <li>Chaffs would include implementations that compute the mean instead of the median, or implementations that do not correctly handle empty lists.</li>
</ul>

<p>Before working on implementing solutions to problems, students were asked to create <em>executable examples</em> for the problem. 
The examples are simple input+output pairs—that is, for some given input, what should the function’s output be?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>median([1]) == 1
median([1, 2, 3]) == 2
median([2, 3, 4, 1]) == 2.5
</code></pre></div></div>

<p>This suite of examples can be assessed as follows:</p>

<ul>
  <li><em>Validity</em> was assessed based on whether or not the examples were accepted by the <em>wheats</em>. If a wheat “fails” an example, it means the example is incorrect. <em>This means the student has formed an incorrect understanding of the problem</em>.<sup id="fnref:wheat-caveat" role="doc-noteref"><a href="#fn:wheat-caveat" class="footnote" rel="footnote">3</a></sup></li>
  <li><em>Thoroughness</em> was assessed based on the number of <em>chaffs</em> that were detected by the student’s set of examples. If a chaff does not “fail” against at least one example, it means the examples are incomplete in terms of the number of cases it covers. <em>This could mean the student has an incomplete understanding of the problem.</em></li>
</ul>

<p>So far, the students have not yet written their own implementations. They are still only testing their understanding of the <strong>problem</strong>.</p>

<p>It’s important to note that these examples are <em>not</em> test cases, even though they look like test cases.
The examples are not being run against the student’s own solution (which may or may not exist yet)—they are being run against <em>the problem prompt</em>.
In this paper, the authors have the examples <em>checkable</em> by implementing a series of correct and incorrect implementations.</p>

<p>Results were promising:</p>

<ul>
  <li>Students used executable examples even when it was not required; it was a helpful metacognitive scaffold.</li>
  <li>The <em>examples</em> students created turned into <em>tests</em> once they went on to implement their own solutions; a win for step 6 of the Design Recipe!</li>
  <li>Test suites were more valid than before—they were less likely to overzealously reject correct implementations based on underspecified behaviour.</li>
  <li>The authors also suggest that the existence of this feature helped reduce load on course staff: if students were not sure of underspecified requirements, they could just “ask the IDE” by probing the problem with examples.</li>
</ul>

<h2 id="discussion">Discussion</h2>

<p class="callout ponder">In groups, discuss amongst yourselves ways in which this focus on metacognitive awareness can factor into your teaching. Consider the different teaching contexts you’ve been in this quarter while you discuss (tutoring, workshops, lab activities).</p>

<hr />

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:loksa" role="doc-endnote">
      <p><a href="https://doi.org/10.1145/2858036.2858252">Programming, Problem Solving, and Self-Awareness: Effects of Explicit Guidance</a>. Loksa, Ko, Jernigan, Oleson, Mendez, &amp; Burnett. <a href="#fnref:loksa" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:false-progress" role="doc-endnote">
      <p>I thought this was particularly insidious. Consider the students who were mistakenly solving the <em>Even/Odd</em> problem instead of <em>Positive/Negative</em>. The list <code class="language-plaintext highlighter-rouge">[4, -3, -5, -7, 1, -2]</code> has more negative numbers than positive numbers <em>and</em> more odd numbers than even numbers. If the function is simply returning <code class="language-plaintext highlighter-rouge">false</code> for “more negative” (or “more odd” for the mistaken students), there will be some overlap in the passing test cases for <em>Even/Odd</em> and <em>Positive/Negative</em>. So these students actually passed some test cases, even though they were solving the wrong problem! And those passing test cases led them to believe that they were on track to correctly solve the problem. <a href="#fnref:false-progress" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:wheat-caveat" role="doc-endnote">
      <p>It can also mean the instructor messed up their solution and the student has found a bug, but this is less likely. <a href="#fnref:wheat-caveat" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

      <footer class="nav-links">
        
        <a href="/courses/csc313/coursenotes/learning-a-second-programming-language/">&larr; Previous</a>
        
        
        <a href="/courses/csc313/coursenotes/spatial-skills/">Next &rarr;</a>
        
      </footer  >
  </article>
  
  
  </main>
</body>
</html>
